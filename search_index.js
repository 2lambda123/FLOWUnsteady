var documenterSearchIndex = {"docs":
[{"location":"api/flowunsteady-vehicle-asm/#Actuator-surface-model","page":"Actuator surface model","title":"Actuator surface model","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-asm/","page":"Actuator surface model","title":"Actuator surface model","text":"FLOWUnsteady.g_uniform\nFLOWUnsteady.g_linear\nFLOWUnsteady.g_piecewiselinear\nFLOWUnsteady.g_pressure","category":"page"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_uniform","page":"Actuator surface model","title":"FLOWUnsteady.g_uniform","text":"Uniform vortex-sheet distribution for actuator surface model. See Alvarez' dissertation, Sec. 6.3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_linear","page":"Actuator surface model","title":"FLOWUnsteady.g_linear","text":"Linear vortex-sheet distribution for actuator surface model. See Alvarez' dissertation, Sec. 6.3.2.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_piecewiselinear","page":"Actuator surface model","title":"FLOWUnsteady.g_piecewiselinear","text":"Alias for FLOWUnsteady.g_linear.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-asm/#FLOWUnsteady.g_pressure","page":"Actuator surface model","title":"FLOWUnsteady.g_pressure","text":"Pressure-like vortex-sheet distribution for actuator surface model. See Alvarez' dissertation, Sec. 6.3.2.\n\n\n\n\n\n","category":"function"},{"location":"installation/general/#installation","page":"Installation","title":"Installation Instructions","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"FLOWUnsteady is developed in the Julia programming language, which is a modern, high-level, dynamic programming language for high-performance computing. For visualization and postprocessing, FLOWUnsteady uses ParaView, which is an open-source software for scientific and HPC visualization.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"The following instructions walk you through how to install Julia, ParaView, and FLOWUnsteady.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: Windows Users\nIf using Windows, please follow these instructions first to set up Windows Subsystem for Linux.","category":"page"},{"location":"installation/general/#Julia","page":"Installation","title":"Julia","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Download and install Julia: julialang.org (we recommend using v1.6.7 LTS or the latest stable release)\nAdd Julia to user-level bin folder\nsudo ln -s /[user-specific-path/Julia-1.x.x]/bin/julia /usr/local/bin/julia\nReplace /[user-specific-path/Julia-1.x.x]/ with the path where Julia got installed. For instance, in MacOS the full path looks like this: /Applications/Julia-1.8.app/Contents/Resources/julia/bin/julia","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you were successfull, typing the following in the terminal will launch the Julia REPL:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"julia","category":"page"},{"location":"installation/general/#paraview","page":"Installation","title":"ParaView","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Download and install ParaView: paraview.org\nAdd ParaView to user-level bin folder\nsudo ln -s /[user-specific-path/ParaView-5.x.x]/paraview /usr/local/bin/paraview\nReplace /[user-specific-path/ParaView-5.x.x]/ with the path where ParaView got installed. For instance, in MacOS the full path looks like this: /Applications/ParaView-5.11.0.app/Contents/MacOS/paraview","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you were successfull, typing the following in the terminal will launch the ParaView:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"paraview","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"To test that ParaView is correctly installed, run one of the examples of the GeometricTools package as follows (copy/paste this in the Julia REPL):","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"# Install GeometricTools\nimport Pkg; Pkg.add(\"GeometricTools\")\n\nimport GeometricTools as gt\n\n# Load example\nexamplepath = joinpath(dirname(pathof(gt)), \"..\", \"examples\", \"example_simple.jl\")\ninclude(examplepath)\n\n# Run example: it will pull up paraview with a good-looking cube\nsimple_box2()","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"ParaView will then pull up with a rendering of a cube (click the Apply button under Properties to make it visible).","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"<p align=\"center\">\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/simple_cube.png\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</p>","category":"page"},{"location":"installation/general/#pycall","page":"Installation","title":"PyCall","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"One of the dependencies (AirfoilPrep.jl) is a wrapper of Python code that is written in Python v3.8+. For this reason, make sure that your Python version linked to PyCall is 3.8 or higher. You can do that as follows:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"# Install PyCall\nimport Pkg; Pkg.add(\"PyCall\")\n\n# Point environment to your Python 3.8 (or higher)\nENV[\"PYTHON\"] = \"path/to/your/python3\"\n\n# Rebuild PyCall\nPkg.build(\"PyCall\")","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Then close and reopen the Julia REPL, and run:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import PyCall\nPyCall.pyversion","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"which should reveal your Python version:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"v\"3.8\"","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Since PyCall now relies on a custom install of Python3, make sure that:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"matplotlib, mpmath, and scipy are installed in that Python,\npip3 install matplotlib mpmath scipy --user\nFor optimal experience, verify that matplotlib uses the Qt5Agg backend. Useful instructions can be found here and here.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you run into errors with PyPlot while running FLOWUnsteady, they are likely related to one of those two items.","category":"page"},{"location":"installation/general/#FLOWVPM","page":"Installation","title":"FLOWVPM","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"FLOWVPM uses a fast multipole code called ExaFMM that accelerates the computation of particle interactions. ExaFMM is written in C++ and we have developed a Julia wrapper for it: FLOWExaFMM.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Before installing FLOWVPM, first you will have to install FLOWExaFMM and compile ExaFMM, as follows.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Make sure you have CMake, GCC, and OpenMP. On Linux, type to following to install them\nsudo apt-get update\nsudo apt-get install cmake g++ mpich\n[Julia REPL] Install CxxWrap:\nimport Pkg\nPkg.add(name=\"CxxWrap\", version=\"0.11.2\")\n[Terminal] Clone FLOWExaFMM:\ngit clone https://github.com/byuflowlab/FLOWExaFMM path/to/FLOWExaFMM\n(replace path/to/FLOWExaFMM with your preferred path in your local)","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Compile ExaFMM running the script build.sh:\ncd path/to/FLOWExaFMM\nsh build.sh\nor in MacOS:\ncd path/to/FLOWExaFMM\nsh build_macos.sh\nThis should have generated the file fmm.so (or fmm.dylib in MacOS) under src/, which is a binary library containing ExaFMM.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Now that ExaFMM is compiled, you can add FLOWExaFMM to your Julia environment as a development package pointing directly to where you compiled the package and add FLOWVPM:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Add FLOWExaFMM:\n# In the Julia REPL\n] develop path/to/FLOWExaFMM","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"[Optional] Test FLOWExaFMM:\n] test FLOWExaFMM\nThis will return a heart-warming \"Hello world!\" if ExaFMM was correctly compiled.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Add FLOWVPM:\n] add https://github.com/byuflowlab/FLOWVPM.jl","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"[Optional] Test FLOWVPM:\n] test FLOWVPM","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If you run into any issues, please try the following:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Test that you can correctly compile C++ code wrapped for Julia following these instructions: LINK\nMac users, take a look at these thread: LINK\nInstructions for BYU Fulton supercomputer: LINK","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"If issues persist, please check the resolved issues in the FLOWExaFMM repo and feel free to open a new issue.","category":"page"},{"location":"installation/general/#Other-Packages","page":"Installation","title":"Other Packages","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"Run the following commands in the Julia REPL to add some dependencies that are not in the official Julia registry:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import Pkg\n\nurl = \"https://github.com/byuflowlab/\"\npackages = (\"AirfoilPrep.jl\", \"FLOWVLM\", \"BPM.jl\", \"FLOWNoise\")\n\nPkg.add([ Pkg.PackageSpec(; url=url*name) for name in packages ])","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: Troubleshooting\nSome things you might need to look out for:(MacOS users) Make sure your Homebrew (in Julia) is up to date. You may need to run the following in order to update your Homebrew: using Homebrew; Homebrew.brew(`update-reset`)\nMake sure that things are in place in your Julia settings. Having things like Conda, HDF5, etc. on your machine doesn't necessarily mean that the Julia implementation has them as well.","category":"page"},{"location":"installation/general/#Add-FLOWUnsteady","page":"Installation","title":"Add FLOWUnsteady","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"You are now ready to install the FLOWUnsteady package. Type this in the Julia REPL:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"] add https://github.com/byuflowlab/FLOWUnsteady","category":"page"},{"location":"installation/general/#Test-FLOWUnsteady","page":"Installation","title":"Test FLOWUnsteady","text":"","category":"section"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"In order to test that FLOWUnsteady and all dependencies were successfully installed, try running some of the examples under FLOWUnsteady/examples/.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"For instance, you can run the Simple Wing example as follows:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import FLOWUnsteady as uns\n\ninclude(joinpath(uns.examples_path, \"wing\", \"wing.jl\"))","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"or you can run the Tethered Wing example:","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"import FLOWUnsteady as uns\n\ninclude(joinpath(uns.examples_path, \"tetheredwing.jl\"))","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"This will pull up Paraview visualizing the simulation. Kick off your shoes, sit back, and enjoy the simulation that you have just run.","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"<br><br>\n\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/tetheredwing-example-00small.gif\" alt=\"Vid here\" style=\"width: 80%;\"/>\n</center>\n\n<br><br><br><br>\n<br><br><br><br>","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: 2D View\nWhen opening a simulation with a flat surface (like wing.jl), ParaView automatically activates its 2D view mode. Disable the 2D view by clicking these two buttons: (Image: pic)","category":"page"},{"location":"installation/general/","page":"Installation","title":"Installation","text":"info: CPU Parallelization\nIf any of the examples is taking longer than 10 to 20 minutes to run, it is possible that ExaFMM was compiled without OpenMP, thus running in only one core as opposed to parallelizing the computation across all your CPU cores.To confirm that ExaFMM is successfully parallelized, pull up whatever CPU monitor is available in your operative system and confirm that Julia is using all the cores as the simulation is running. For instance, the Resources tab of the Task Manager in Windows should look like this: (Image: pic) and htop in the terminal (Linux and MacOS) should look like this: (Image: pic)","category":"page"},{"location":"api/flowunsteady-monitor/#(4)-Monitors-Definitions","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"A monitor is a function that is passed to FLOWUnsteady.run_simulation as an extra runtime function that is called at every time step. Runtime functions are expected to return a Boolean that indicates the need of stopping the simulation, such that if extra_runtime_function ever returns true, the simulation will immediately be ended.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Multiple monitors can be concatenated with boolean logic as follows","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"import FLOWUnsteady as uns\n\nmonitor_states = uns.generate_monitor_statevariables()\nmonitor_enstrophy = uns.generate_monitor_enstrophy()\n\nmonitors(args...; optargs...) = monitor_states(args...; optargs...) || monitor_enstrophy(args...; optargs...)","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Then pass the monitor to the simulation as","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"uns.run_simulation(sim, nsteps; extra_runtime_function=monitors, ...)","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"compat: Monitor concatenation\nFLOWUnsteady facilitates the concatenation of monitors through the function FLOWUnsteady.concatenate. Using this function, the example above looks like this:monitor_states = uns.generate_monitor_statevariables()\nmonitor_enstrophy = uns.generate_monitor_enstrophy()\n\nallmonitors = [monitor_states, monitor_enstrophy]\n\nmonitors = uns.concatenate(monitors)\n\nuns.run_simulation(sim, nsteps; extra_runtime_function=monitors, ...)","category":"page"},{"location":"api/flowunsteady-monitor/#Monitor-Generators","page":"(4) Monitors Definitions","title":"Monitor Generators","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"The following are functions for generating the monitors that serve most use cases. See the source code of these monitors to get an idea of how to write your own user-defined monitors.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"FLOWUnsteady.generate_monitor_statevariables\nFLOWUnsteady.generate_monitor_wing\nFLOWUnsteady.generate_monitor_rotors\nFLOWUnsteady.generate_monitor_enstrophy\nFLOWUnsteady.generate_monitor_Cd\nFLOWUnsteady.concatenate","category":"page"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_statevariables","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_statevariables","text":"generate_monitor_statevariables(; save_path=nothing)\n\nGenerate a monitor plotting the state variables of the vehicle at every time step. The state variables are vehicle velocity, vehicle angular velocity, and vehicle position.\n\nUse save_path to indicate a directory where to save the plots.\n\nHere is an example of this monitor on a vehicle flying a circular path: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_wing","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_wing","text":"generate_monitor_wing(wing::Union{vlm.Wing, vlm.WingSystem},\n                        Vinf::Function, b_ref::Real, ar_ref::Real,\n                        rho_ref::Real, qinf_ref::Real, nsteps_sim::Int;\n                        L_dir=[0,0,1],      # Direction of lift component\n                        D_dir=[1,0,0],      # Direction of drag component\n                        calc_aerodynamicforce_fun=FLOWUnsteady.generate_calc_aerodynamicforce())\n\nGenerate a wing monitor computing and plotting the aerodynamic force and wing loading at every time step.\n\nThe aerodynamic force is integrated, decomposed, and reported as overall lift coefficient C_L = fracLfrac12rho u_infty^2 b c and drag coefficient C_D = fracDfrac12rho u_infty^2 b c. The wing loading is reported as the sectional lift and drag coefficients defined as c_ell = fracellfrac12rho u_infty^2 c and c_d = fracdfrac12rho u_infty^2 c, respectively.\n\nThe aerodynamic force is calculated through the function calc_aerodynamicforce_fun, which is a user-defined function. The function can also be automatically generated through, generate_calc_aerodynamicforce which defaults to incluiding the Kutta-Joukowski force, parasitic drag (calculated from a NACA 0012 airfoil polar), and unsteady-circulation force.\n\nb_ref       : Reference span length.\nar_ref      : Reference aspect ratio, used to calculate the equivalent chord c = fracbmathrmar.\nrho_ref     : Reference density.\nqinf_ref    : Reference dynamic pressure q_infty = frac12rho u_infty^2.\nnsteps_sim  : the number of time steps by the end of the simulation (used for generating the color gradient).\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with C_L and C_D.\n\nHere is an example of this monitor: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_rotors","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_rotors","text":"generate_monitor_rotors(rotors::Array{vlm.Rotor}, J_ref::Real,\n                            rho_ref::Real, RPM_ref::Real, nsteps_sim::Int;\n                            save_path=nothing)\n\nGenerate a rotor monitor plotting the aerodynamic performance and blade loading at every time step.\n\nThe aerodynamic performance consists of thrust coefficient C_T=fracTrho n^2 d^4, torque coefficient C_Q = fracQrho n^2 d^5, and propulsive efficiency eta = fracT u_infty2pi n Q.\n\nJ_ref and rho_ref are the reference advance ratio and air density used for calculating propulsive efficiency and coefficients. The advance ratio used here is defined as J=fracu_inftyn d with n = fracmathrmRPM60.\nRPM_ref is the reference RPM used to estimate the age of the wake.\nnsteps_sim is the number of time steps by the end of the simulation (used for generating the color gradient).\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with C_T, C_Q, and eta.\n\n(Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_enstrophy","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_enstrophy","text":"generate_monitor_enstrophy(; save_path=nothing)\n\nGenerate a monitor plotting the global enstrophy of the flow at every time step (computed through the particle field). This is calculated by integrating the local enstrophy defined as ξ = ω⋅ω / 2.\n\nEnstrophy is approximated as 0.5*Σ( Γ𝑝⋅ω(x𝑝) ). This is consistent with Winckelamns' 1995 CTR report, \"Some Progress in LES using the 3-D VPM\".\n\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with ξ.\n\nHere is an example of this monitor: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_monitor_Cd","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_monitor_Cd","text":"generate_monitor_Cd(; save_path=nothing)\n\nGenerate a monitor plotting the mean value of the SFS model coefficient C_d across the particle field at every time step. It also plots the ratio of C_d values that were clipped to zero (not included in the mean).\n\nUse save_path to indicate a directory where to save the plots. If so, it will also generate a CSV file with the statistics of C_d (particles whose coefficients have been clipped are ignored).\n\nHere is an example of this monitor: (Image: image)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.concatenate","page":"(4) Monitors Definitions","title":"FLOWUnsteady.concatenate","text":"concatenate(monitors::Array{Function})\nconcatenate(monitors::NTuple{N, Function})\nconcatenate(monitor1, monitor2, ...)\n\nConcatenates a collection of monitors into a pipeline, returning one monitor of the form\n\nmonitor(args...; optargs...) =\n    monitors[1](args...; optargs...) || monitors[2](args...; optargs...) || ...\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#Force-Calculators","page":"(4) Monitors Definitions","title":"Force Calculators","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"The following are some possible methods for calculating aerodynamic forces. Generator functions return a function that can be directly passed to FLOWUnsteady.generate_monitor_wing through the keyword argument calc_aerodynamicforce_fun.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"FLOWUnsteady.generate_calc_aerodynamicforce\nFLOWUnsteady.generate_aerodynamicforce_kuttajoukowski\nFLOWUnsteady.generate_aerodynamicforce_parasiticdrag\nFLOWUnsteady.calc_aerodynamicforce_unsteady","category":"page"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_calc_aerodynamicforce","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_calc_aerodynamicforce","text":"generate_calc_aerodynamicforce(; add_parasiticdrag=false,\n                                      add_skinfriction=true,\n                                      airfoilpolar=\"xf-n0012-il-500000-n5.csv\",\n                                      parasiticdrag_args=(),\n                                      )\n\nDefault method for calculating aerodynamic forces.\n\nPass the output of this function to generate_monitor_wing, or use this as an example on how to define your own costumized force calculations.\n\nThis function stitches together the outputs of generate_aerodynamicforce_kuttajoukowski and generate_aerodynamicforce_parasiticdrag, and calc_aerodynamicforce_unsteady. See Alvarez' dissertation, Sec. 6.3.3.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_aerodynamicforce_kuttajoukowski","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_aerodynamicforce_kuttajoukowski","text":"generate_aerodynamicforce_kuttajoukowski(KJforce_type::String,\n                            sigma_vlm_surf, sigma_rotor_surf,\n                            vlm_vortexsheet,\n                            vlm_vortexsheet_overlap,\n                            vlm_vortexsheet_distribution,\n                            vlm_vortexsheet_sigma_tbv;\n                            vehicle=nothing\n                            )\n\nCalculates the aerodynamic force at each element of a VLM system using its current Gamma solution and the Kutta-Joukowski theorem. It saves the force as the field vlm_system.sol[\"Ftot\"]\n\nThis force calculated through the Kutta-Joukowski theorem uses the freestream velocity, kinematic velocity, and wake-induced velocity on each bound vortex. See Alvarez' dissertation, Sec. 6.3.3.\n\nARGUMENTS\n\nvlm_vortexsheet::Bool   : If true, the bound vorticity is approximated with                               and actuator surface model through a vortex                               sheet. If false, it is approximated with an                               actuator line model with horseshoe vortex                               filaments.\nvlm_vortexsheet_overlap::Bool       : Target core overlap between particles                               representing the vortex sheet (if                               vlm_vortexsheet=true).\nvlm_vortexsheet_distribution::Function : Vorticity distribution in vortex                               sheet (see g_uniform, g_linear, and                               g_pressure).\nKJforce_type::String    : If vlm_vortexsheet=true, it specifies how to                               weight the force of each particle in the vortex                               sheet. If KJforce_type==\"averaged\", the KJ                               force is a chordwise average of the force                               experienced by the particles. If                               KJforce_type==\"weighted\", the KJ force                               is chordwise weighted by the strength of each                               particle. If KJforce_type==\"regular\", the                               vortex sheet is ignored, and the KJ force                               is calculated from the velocity induced                               at midpoint between the horseshoe filaments.\nvehicle::VLMVehicle     : If vlm_vortexsheet=true, it is expected that the                               vehicle object is passed through this argument.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.generate_aerodynamicforce_parasiticdrag","page":"(4) Monitors Definitions","title":"FLOWUnsteady.generate_aerodynamicforce_parasiticdrag","text":"generate_aerodynamicforce_parasiticdrag(polar_file::String;\n                                                read_path=FLOWUnsteady.default_database*\"/airfoils\",\n                                                calc_cd_from_cl=false,\n                                                add_skinfriction=true,\n                                                Mach=nothing)\n\nCalculates the parasitic drag along the wing using a lookup airfoil table. It adds this force to the field vlm_system.sol[\"Ftot\"].\n\nThe lookup table is read from the file polar_file under the directory read_path. The parasitic drag includes form drag, skin friction, and wave drag, assuming that each of these components are included in the lookup polar. polar_file can be any polar file downloaded from airfoiltools.com.\n\nTo ignore skin friction drag, use add_skinfriction=false.\n\nThe drag will be calculated from the local effective angle of attack, unless calc_cd_from_cl=true is used, which then will be calculated from the local lift coefficient given by the circulation distribution. cd from cl tends to be more accurate than from AOA, but the method might fail to correlate cd and cl depending on how noise the polar data is.\n\nIf Mach != nothing, it will use a Prandtl-Glauert correction to pre-correct the lookup cl. This will have no effects if calc_cd_from_cl=false.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.calc_aerodynamicforce_unsteady","page":"(4) Monitors Definitions","title":"FLOWUnsteady.calc_aerodynamicforce_unsteady","text":"calc_aerodynamicforce_unsteady(vlm_system::Union{vlm.Wing, vlm.WingSystem},\n                            prev_vlm_system, pfield, Vinf, dt, rho; t=0.0,\n                            per_unit_span=false, spandir=[0, 1, 0],\n                            include_trailingboundvortex=false,\n                            add_to_Ftot=false\n                            )\n\nForce from unsteady circulation.\n\nThis force tends to add a lot of numerical noise, which in most cases ends up cancelling out when the loading is time-averaged. Hence, add_to_Ftot=false will calculate the unsteady loading and save it under the field Funs-vector, but it will not be added to the Ftot vector that is used to calculate the wing's overall aerodynamic force.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#Wake-Treatment","page":"(4) Monitors Definitions","title":"Wake Treatment","text":"","category":"section"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Since the full set of state variables is passed to extra_runtime_function, this function can also be used to alter the simulation on the fly. In some circumstances it is desirable to be able to remove or modify particles, which process we call \"wake treatment.\" Wake treatment is often used to reduce computational cost (for instance, by removing particle in regions of the flow that are not of interest), and it can also be used to force numerical stability (for instance, by removing or clipping particles with vortex strengths that grow beyond certain threshold).","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"These wake treatment methods can be added into the pipeline of extra_runtime_function as follows:","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"import FLOWUnsteady as uns\n\n# Define monitors\nmonitor_states = uns.generate_monitor_statevariables()\nmonitor_enstrophy = uns.generate_monitor_enstrophy()\n\n# Monitor pipeline\nmonitors(args...; optargs...) = monitor_states(args...; optargs...) || monitor_enstrophy(args...; optargs...)\n\n# Define wake treatment\nwake_treatment = uns.remove_particles_sphere(1.0, 1; Xoff=zeros(3))\n\n# Extra runtime function pipeline\nextra_runtime_function(args...; optargs...) = monitors(args...; optargs...) || wake_treatment(args...; optargs...)\n","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Then pass this pipeline to the simulation as","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"uns.run_simulation(sim, nsteps; extra_runtime_function=extra_runtime_function, ...)","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"Below we list a few generator functions that return common wake treatment methods.","category":"page"},{"location":"api/flowunsteady-monitor/","page":"(4) Monitors Definitions","title":"(4) Monitors Definitions","text":"FLOWUnsteady.remove_particles_sphere\nFLOWUnsteady.remove_particles_box\nFLOWUnsteady.remove_particles_lowstrength\nFLOWUnsteady.remove_particles_strength\nFLOWUnsteady.remove_particles_sigma","category":"page"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_sphere","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_sphere","text":"remove_particles_sphere(Rsphere2, step::Int; Xoff::Vector=zeros(3))\n\nReturns an extra_runtime_function that every step steps removes all particles that are outside of a sphere of radius sqrt(Rsphere2) centered around the vehicle or with an offset Xoff from the center of the vehicle.\n\nUse this wake treatment to avoid unnecesary computation by removing particles that have gone beyond the region of interest.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_box","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_box","text":"remove_particles_box(Pmin::Vector, Pmax::Vector, step::Int)\n\nReturns an extra_runtime_function that every step steps removes all particles that are outside of a box of minimum and maximum vertices Pmin and Pmax.\n\nUse this wake treatment to avoid unnecesary computation by removing particles that have gone beyond the region of interest.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_lowstrength","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_lowstrength","text":"remove_particles_lowstrength(critGamma2, step)\n\nReturns an extra_runtime_function that removes all particles with a vortex strength magnitude that is smaller than sqrt(critGamma2). Use this wake treatment to avoid unnecesary computation by removing particles that have negligibly-low strength.\n\nstep indicates every how many steps to remove particles.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_strength","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_strength","text":"remove_particles_strength(minGamma2, maxGamma2; every_nsteps=1)\n\nReturns an extra_runtime_function that removes all particles with a vortex strength magnitude that is larger than sqrt(maxGamma2) or smaller than sqrt(minGamma2). Use every_nsteps to indicate every how many steps to remove particles.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-monitor/#FLOWUnsteady.remove_particles_sigma","page":"(4) Monitors Definitions","title":"FLOWUnsteady.remove_particles_sigma","text":"remove_particles_sigma(minsigma, maxsigma; every_nsteps=1)\n\nReturns an extra_runtime_function that removes all particles with a smoothing radius that is larger than maxsigma or smaller than minsigma. Use every_nsteps to indicate every how many steps to remove particles.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-utils/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/flowvpm-utils/","page":"Utilities","title":"Utilities","text":"FLOWUnsteady.vpm.run_vpm!\nFLOWUnsteady.vpm.save\nFLOWUnsteady.vpm.read\nFLOWUnsteady.vpm.save_settings\nFLOWUnsteady.vpm.read_settings","category":"page"},{"location":"api/flowvpm-utils/#FLOWVPM.run_vpm!","page":"Utilities","title":"FLOWVPM.run_vpm!","text":"run_vpm!(pfield, dt, nsteps; runtime_function=nothing, save_path=nothing, run_name=\"pfield\", nsteps_save=1, verbose=true, prompt=true)\n\nSolves nsteps of the particle field with a time step of dt.\n\nOptional Arguments\n\nruntime_function::Function   : Give it a function of the form                           myfun(pfield, t, dt). On each time step it                           will call this function. Use this for adding                           particles, deleting particles, etc.\nstatic_particles_function::Function   : Give it a function of the form                           myfun(pfield, t, dt) to add static particles                           representing solid boundaries to the solver. This                           function is called at every time step right before                           solving the governing equations, and any new                           particles added by this function are immediately                           removed.\nsave_path::String   : Give it a string for saving VTKs of the particle                           field. Creates the given path.\nrun_name::String    : Name of output files.\nnsteps_save::Int64  : Saves vtks every this many time steps.\nprompt::Bool        : If save_path already exist, it will prompt the                           user before overwritting the folder if true; it will                           directly overwrite it if false.\nverbose::Bool       : Prints progress of the run to the terminal.\nverbose_nsteps::Bool: Number of time steps between verbose.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-utils/#FLOWVPM.save","page":"Utilities","title":"FLOWVPM.save","text":"save(pfield, file_name; path=\"\")\n\nSaves the particle field in HDF5 format and a XDMF file especifying its the attributes. This format can be opened in Paraview for post-processing and visualization.\n\n\n\n\n\n","category":"function"},{"location":"examples/rotorhover-aero/#Variable-Fidelity","page":"Variable Fidelity","title":"Variable Fidelity","text":"","category":"section"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/u9SgYbYhPpU?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"While propeller simulations tend to be numerically well behaved, hover cases can pose multiple numerical challenges. The rotation of blades in static air drives a strong axial flow that is solely caused by the shedding of tip vortices. This is challenging to simulate since, in the absence of a freestream, the wake quickly becomes fully turbulent and breaks down as tip vortices leapfrog and mix close to the rotor. Thus, a rotor in hover is a good engineering application to showcase the numerical stability and accuracy of FLOWUnsteady.","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"In this example we simulate a DJI rotor in hover, and we use this case to demonstrate some of the advanced features of FLOWUnsteady that make it robust and accurate in resolving turbulent mixing:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Subfilter scale (SFS) model of turbulence related to vortex stretching\nHow to generate a monitor of dynamic SFS model coefficient   uns.generate_monitor_Cd\nHow to generate a monitor of global flow enstrophy with   uns.generate_monitor_enstrophy to track numerical stability\nDefining a wake treatment procedure to suppress initial hub wake, avoiding   hub fountain effects and accelerating convergence\nDefining hub and tip loss corrections","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Also, in this example you can vary the fidelity of the simulation with the following parameters:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Parameter Mid-low fidelity Mid-high fidelity High fidelity Description\nn 20 50 50 Number of blade elements per blade\nnsteps_per_rev 36 72 360 Time steps per revolution\np_per_step 4 2 2 Particle sheds per time step\nsigma_rotor_surf R/10 R/10 R/80 Rotor-on-VPM smoothing radius\nsigmafactor_vpmonvlm 1.0 1.0 5.5 Expand particles by this factor when calculating VPM-on-VLM/Rotor induced velocities\nshed_starting false false true Whether to shed starting vortex\nsuppress_fountain true true false Whether to suppress hub fountain effect\nvpm_integration vpm.euler RK3^star RK3^star VPM time integration scheme\nvpm_SFS None^dag None^dag Dynamic^ddag VPM LES subfilter-scale model","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"^starRK3: vpm_integration = vpm.rungekutta3\n^dagNone: vpm_SFS = vpm.SFS_none\n^ddagDynamic: vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<br>\n\n<center><b>Spatial discretization</b></center>\n\n<table>\n    <tr>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-midlow-00.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n        </td>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-midhigh-00.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n        </td>\n        <td>\n            <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//singlerotor-particlescomp-high-03.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n        </td>\n    </tr>\n        <tr>\n            <th><center>Mid-Low</center></th>\n            <th><center>Mid-High</center></th>\n            <th><center>High</center></th>\n        </tr>\n</table>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<br>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of a DJI 9443 rotor in hover (two-bladed rotor, 9.4 inches\n    diameter).\n\n    This example replicates the experiment described in Zawodny & Boyd (2016),\n    \"Acoustic Characterization and Prediction of Representative,\n    Small-scale Rotary-wing Unmanned Aircraft System Components.\"\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\nimport FLOWVPM as vpm\n\nrun_name        = \"rotorhover-example\"      # Name of this simulation\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n\n# Rotor geometry\nrotor_file      = \"DJI9443.csv\"             # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 0.0                       # (deg) collective pitch of blades\nCW              = false                     # Clock-wise rotation\nxfoil           = false                     # Whether to run XFOIL\nread_polar      = vlm.ap.read_polar2        # What polar reader to use\n\n# NOTE: If `xfoil=true`, XFOIL will be run to generate the airfoil polars used\n#       by blade elements before starting the simulation. XFOIL is run\n#       on the airfoil contours found in `rotor_file` at the corresponding\n#       local Reynolds and Mach numbers along the blade.\n#       Alternatively, the user can provide pre-computer airfoil polars using\n#       `xfoil=false` and providing the polar files through `rotor_file`.\n#       `read_polar` is the function that will be used to parse polar files. Use\n#       `vlm.ap.read_polar` for files that are direct outputs of XFOIL (e.g., as\n#       downloaded from www.airfoiltools.com). Use `vlm.ap.read_polar2` for CSV\n#       files.\n\n# Discretization\nn               = 20                        # Number of blade elements per blade\nr               = 1/10                      # Geometric expansion of elements\n\n# NOTE: Here a geometric expansion of 1/10 means that the spacing between the\n#       tip elements is 1/10 of the spacing between the hub elements. Refine the\n#       discretization towards the blade tip like this in order to better\n#       resolve the tip vortex.\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n\n# Operating conditions\nRPM             = 5400                      # RPM\nJ               = 0.0001                    # Advance ratio Vinf/(nD)\nAOA             = 0                         # (deg) Angle of attack (incidence angle)\n\nrho             = 1.071778                  # (kg/m^3) air density\nmu              = 1.85508e-5                # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\n\n# NOTE: For cases with zero freestream velocity, it is recommended that a\n#       negligible small velocity is used instead of zero in order to avoid\n#       potential numerical instabilities (hence, J here is negligible small\n#       instead of zero)\n\nmagVinf         = J*RPM/60*(2*R)\nVinf(X, t)      = magVinf*[cos(AOA*pi/180), sin(AOA*pi/180), 0]  # (m/s) freestream velocity vector\n\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number\nMatip           = 2*pi*RPM/60 * R / speedofsound    # Tip Mach number\n\nprintln(\"\"\"\n    RPM:    $(RPM)\n    Vinf:   $(Vinf(zeros(3), 0)) m/s\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType     = uns.QVLMVehicle         # Quasi-steady solver\nconst_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the\n                                                # solution is constant or not\n# Time parameters\nnrevs           = 10                        # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 4                         # Sheds per time step\nshed_starting   = false                     # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nunsteady_shedcrit = 0.001                   # Shed unsteady loading whenever circulation\n                                            #  fluctuates by more than this ratio\nmax_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\n\n# Regularization\nsigma_rotor_surf= R/10                      # Rotor-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\nsigmafactor_vpmonvlm= 1                     # Shrink particles by this factor when\n                                            #  calculating VPM-on-VLM/Rotor induced velocities\n\n# Rotor solver\nvlm_rlx         = 0.5                       # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction = ((0.4, 5, 0.1, 0.05), (2, 1, 0.25, 0.05)) # Hub and tip correction\n\n# VPM solver\nvpm_integration = vpm.euler                 # VPM temporal integration scheme\n# vpm_integration = vpm.rungekutta3\n\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n# vpm_viscous   = vpm.CoreSpreading(-1, -1, vpm.zeta_fmm; beta=100.0, itmax=20, tol=1e-1)\n\nvpm_SFS         = vpm.SFS_none              # VPM LES subfilter-scale model\n# vpm_SFS       = vpm.SFS_Cd_twolevel_nobackscatter\n# vpm_SFS       = vpm.SFS_Cd_threelevel_nobackscatter\n# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n#                                   alpha=0.999, maxC=1.0,\n#                                   clippings=[vpm.clipping_backscatter])\n# vpm_SFS       = vpm.DynamicSFS(vpm.Estr_fmm, vpm.pseudo3level_positive;\n#                                   alpha=0.999, rlxf=0.005, minC=0, maxC=1\n#                                   clippings=[vpm.clipping_backscatter],\n#                                   controls=[control_sigmasensor],\n#                                   )\n\n# NOTE: In most practical situations, open rotors operate at a Reynolds number\n#       high enough that viscous diffusion in the wake is actually negligible.\n#       Hence, it does not make much of a difference whether we run the\n#       simulation with viscous diffusion enabled or not. On the other hand,\n#       such high Reynolds numbers mean that the wake quickly becomes turbulent\n#       and it is crucial to use a subfilter-scale (SFS) model to accurately\n#       capture the turbulent decay of the wake (turbulent diffusion).\n\nif VehicleType == uns.QVLMVehicle\n    # Mute warnings regarding potential colinear vortex filaments. This is\n    # needed since the quasi-steady solver will probe induced velocities at the\n    # lifting line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n\n\n# ----------------- WAKE TREATMENT ---------------------------------------------\n# NOTE: It is known in the CFD community that rotor simulations with an\n#       impulsive RPM start (*i.e.*, 0 to RPM in the first time step, as opposed\n#       to gradually ramping up the RPM) leads to the hub \"fountain effect\",\n#       with the root wake reversing the flow near the hub.\n#       The fountain eventually goes away as the wake develops, but this happens\n#       very slowly, which delays the convergence of the simulation to a steady\n#       state. To accelerate convergence, here we define a wake treatment\n#       procedure that suppresses the hub wake for the first three revolutions,\n#       avoiding the fountain effect altogether.\n#       This is especially helpful in low and mid-fidelity simulations.\n\nsuppress_fountain   = true                  # Toggle\n\n# Supress wake shedding on blade elements inboard of this r/R radial station\nno_shedding_Rthreshold = suppress_fountain ? 0.35 : 0.0\n\n# Supress wake shedding for this many time steps\nno_shedding_nstepsthreshold = 3*nsteps_per_rev\n\nomit_shedding = []          # Index of blade elements to supress wake shedding\n\n# Function to suppress or activate wake shedding\nfunction wake_treatment_supress(sim, args...; optargs...)\n\n    # Case: start of simulation -> suppress shedding\n    if sim.nt == 1\n\n        # Identify blade elements on which to suppress shedding\n        for i in 1:vlm.get_m(rotor)\n            HS = vlm.getHorseshoe(rotor, i)\n            CP = HS[5]\n\n            if uns.vlm.norm(CP - vlm._get_O(rotor)) <= no_shedding_Rthreshold*R\n                push!(omit_shedding, i)\n            end\n        end\n    end\n\n    # Case: sufficient time steps -> enable shedding\n    if sim.nt == no_shedding_nstepsthreshold\n\n        # Flag to stop suppressing\n        omit_shedding .= -1\n\n    end\n\n    return false\nend\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, blade_r=r,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        read_polar=read_polar,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        plot_disc=true\n                                        );\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Rotor\", rotor)\n\nrotors = [rotor];                           # Defining this rotor as its own system\nrotor_systems = (rotors, );                 # All systems of rotors\n\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    vlm.addwing(wake_system, \"Rotor\", rotor)\nend\n\nvehicle = VehicleType(   system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = zeros(3)\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n# Restart simulation\nrestart_file = nothing\n\n# NOTE: Uncomment the following line to restart a previous simulation.\n#       Point it to a particle field file (with its full path) at a specific\n#       time step, and `run_simulation` will start this simulation with the\n#       particle field found in the restart simulation.\n\n# restart_file = \"/path/to/a/previous/simulation/rotorhover-example_pfield.360\"\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# Generate rotor monitor\nmonitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                            t_scale=RPM/60,        # Scaling factor for time in plots\n                                            t_lbl=\"Revolutions\",   # Label for time axis\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"rotor monitor\",\n                                            )\n\n# Generate monitor of flow enstrophy (numerical stability)\nmonitor_enstrophy = uns.generate_monitor_enstrophy(;\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"enstrophy monitor\"\n                                            )\n\n# Generate monitor of SFS model coefficient Cd\nmonitor_Cd = uns.generate_monitor_Cd(;\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"Cd monitor\"\n                                            )\n# Concatenate monitors\nmonitors = uns.concatenate(monitor_rotor, monitor_enstrophy, monitor_Cd)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\n# Concatenate monitors and wake treatment procedure into one runtime function\nruntime_function = uns.concatenate(monitors, wake_treatment_supress)\n\n# Run simulation\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, sound_spd=speedofsound,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    vpm_integration=vpm_integration,\n                    vpm_viscous=vpm_viscous,\n                    vpm_SFS=vpm_SFS,\n                    sigma_vlm_surf=sigma_rotor_surf,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    sigmafactor_vpmonvlm=sigmafactor_vpmonvlm,\n                    vlm_rlx=vlm_rlx,\n                    hubtiploss_correction=hubtiploss_correction,\n                    shed_starting=shed_starting,\n                    shed_unsteady=shed_unsteady,\n                    unsteady_shedcrit=unsteady_shedcrit,\n                    omit_shedding=omit_shedding,\n                    extra_runtime_function=runtime_function,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    save_wopwopin=true,  # <--- Generates input files for PSU-WOPWOP noise analysis\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_pfield...xmf;\")\n    for bi in 1:B\n        global files\n        files *= run_name*\"_Rotor_Blade$(bi)_loft...vtk;\"\n        files *= run_name*\"_Rotor_Blade$(bi)_vlm...vtk;\"\n    end\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Mid-low fidelity runtime: ~7 minutes on a 16-core AMD EPYC 7302 processor. <br>\n    Mid-high fidelity runtime: ~60 minutes on a 16-core AMD EPYC 7302 processor. <br>\n    High fidelity runtime: ~30 hours on a 16-core AMD EPYC 7302 processor.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"Rotor monitor in the high-fidelity case:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotor_convergence.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"As the simulation runs, you will see the monitor shown below plotting the global enstrophy of the flow. The global enstrophy achieves a steady state once the rate of enstrophy produced by the rotor eventually balances out with the forward scatter of the SFS turbulence model, making the simulation indefinitely stable.","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotorenstrophy.png\" alt=\"Pic here\" style=\"width:50%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"The SFS model uses a dynamic procedure to compute its own model coefficient C_d as the simulation evolves. This model coefficient has a different value for each particle in space and time. The C_d-monitor shown below plots the mean value from all the particle in the field that have a non-zero C_d (left), and also the ratio of the number of particles that got clipped to a zero C_d over the total number of particles (right).","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//rotorhover-example-high02-singlerotorChistory.png\" alt=\"Pic here\" style=\"width:100%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"info: Prescribing the Model Coefficient\nThe SFS model helps the simulation to more accurately capture the effects of turbulence from the scales that are not resolved, but it comes with a computational cost. The following table summarizes the cost of the rVPM, the SFS model, and the C_d dynamic procedure. (Image: pic) The dynamic procedure is the most costly operation, which increases the simulation runtime by about 35%.If you need to run a case multiple times with only slight changes (e.g., sweeping the AOA and/or RPM), you can first run the simulation with the dynamic procedure (vpm_SFS = vpm.SFS_Cd_twolevel_nobackscatter), take note of what the mean C_d shown in the monitor converges to, and then prescribe that value to subsequent simulations. Prescribing C_d ends up in a simulation that is only 8% slower than the classic VPM without any SFS model.C_d can then be prescribed as followsvpm_SFS = vpm.ConstantSFS(vpm.Estr_fmm; Cs=value, clippings=[vpm.clipping_backscatter])where CS = value is the value to prescribe for the model coefficient, and clippings=[vpm.clipping_backscatter] clips the backscatter of enstrophy (making it a purely diffusive model). As a reference, in this hover case, C_d converges to 026 in the high-fidelity simulation.","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"In examples/rotorhover/rotorhover_postprocess.jl we show how to postprocess the simulations to compare C_T and blade loading to experimental data by Zawodny & Boyd[1] and a URANS simulation (STAR-CCM+) by Schenk[2]:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-CTcomparison.png\" alt=\"Pic here\" style=\"width:75%;\"/>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-loadingcomparison.png\" alt=\"Pic here\" style=\"width:75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":" C_T Error\nExperimental 0.072 –\nURANS 0.071 1%\nrVPM – high fidelity 0.073 1%\nrVPM – mid-high fidelity 0.066 8%\nrVPM – mid-low fidelity 0.064 11%\nBEMT (quasi-steady) 0.073 2%","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"[1]: N. S. Zawodny, D. D. Boyd, Jr., and C. L. Burley, “Acoustic Characterization and Prediction of Representative, Small-scale Rotary-wing Unmanned Aircraft System Components,” in 72nd American Helicopter Society (AHS) Annual Forum (2016).","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"[2]: A. R. Schenk, \"Computational Investigation of the Effects of Rotor-on-Rotor Interactions on Thrust and Noise,\" Masters thesis, Brigham Young University (2020).","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"info: Hub/Tip Loss Correction\nIn the rotor actuator line model, hub and tip corrections can be applied to c_ell to account for the effects that bring the aerodynamic loading to zero at the hub and tips. These correction factors, F_mathrmtip and F_mathrmhub, are defined as modified Prandtl loss functions,beginalign*\n    F_mathrmtip\n =\n    frac2pi cos^-1 left( expleft( -f_mathrmtip right) right)\n qquad\n    f_mathrmtip\n=\n    fracB2\n    frac\n        left  left( fracR_mathrmrotorr right)^t_1 - 1  right^t_2\n    \n        vert sin left( theta_mathrmeff right) vert^t_3\n    \n\n    F_mathrmhub\n =\n    frac2pi cos^-1 left( expleft( -f_mathrmhub right) right)\n qquad\n    f_mathrmhub\n=\n    fracB2\n    frac\n        left  left( fracrR_mathrmhub right)^h_1 - 1  right^h_2\n    \n        vert sin left( theta_mathrmeff right) vert^h_3\n    \nendalign*where R_mathrmrotor and R_mathrmhub are the rotor and hub radii, B is the number of blades, r is the radial position of the blade element, and t_1, t_2, t_3, h_1, h_2, and h_3 are tunable parameters. The normal and tangential force coefficients, respectively c_n and c_t, are then calculated asbeginalign*\n    c_n\n =\n    F_mathrmtip F_mathrmhub c_ellcostheta_mathrmeff + c_dsintheta_mathrmeff\n\n    c_t\n =\n    F_mathrmtip F_mathrmhub c_ellsintheta_mathrmeff - c_dcostheta_mathrmeff\nendalign*The hub and tip corrections are passed to uns.run_simulation through the keyword argument hubtiploss_correction = ((t1, t2, t3, tminangle), (h1, h2, h3, hminangle)), where tminangle and hminangle are clipping thresholds for the minimum allowable value of verttheta_mathrmeffvert (in degs) that is used in tip and hub corrections. The following corrections are predefined in FLOWVLM for the user:","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"import FLOWVLM as vlm\n\n# No corrections\nvlm.hubtiploss_nocorrection","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"import FLOWUnsteady: vlm            # hide\n\n# Original Prandtl corrections\nvlm.hubtiploss_correction_prandtl","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"import FLOWUnsteady: vlm            # hide\n\n# Modified Prandtl with a strong hub correction\nvlm.hubtiploss_correction_modprandtl","category":"page"},{"location":"examples/rotorhover-aero/","page":"Variable Fidelity","title":"Variable Fidelity","text":"info: ParaView Visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"api/flowvpm-relaxation/#Relaxation-Scheme","page":"Relaxation Scheme","title":"Relaxation Scheme","text":"","category":"section"},{"location":"api/flowvpm-relaxation/","page":"Relaxation Scheme","title":"Relaxation Scheme","text":"FLOWUnsteady.vpm.FMM\nFLOWUnsteady.vpm.Relaxation\nFLOWUnsteady.vpm.relax_pedrizzetti\nFLOWUnsteady.vpm.relax_correctedpedrizzetti","category":"page"},{"location":"api/flowvpm-relaxation/#FLOWVPM.FMM","page":"Relaxation Scheme","title":"FLOWVPM.FMM","text":"`FMM(; p::Int=4, ncrit::Int=50, theta::Real=0.4, phi::Real=0.3)`\n\nParameters for FMM solver.\n\nArguments\n\np       : Order of multipole expansion (number of terms).\nncrit   : Maximum number of particles per leaf.\ntheta   : Neighborhood criterion. This criterion defines the distance               where the far field starts. The criterion is that if θ*r < R1+R2               the interaction between two cells is resolved through P2P, where               r is the distance between cell centers, and R1 and R2 are each               cell radius. This means that at θ=1, P2P is done only on cells               that have overlap; at θ=0.5, P2P is done on cells that their               distance is less than double R1+R2; at θ=0.25, P2P is done on               cells that their distance is less than four times R1+R2; at               θ=0, P2P is done on cells all cells.\nphi     : Regularizing neighborhood criterion. This criterion avoid               approximating interactions with the singular-FMM between               regularized particles that are sufficiently close to each other               across cell boundaries. Used together with the θ-criterion, P2P               is performed between two cells if φ < σ/dx, where σ is the               average smoothing radius in between all particles in both cells,               and dx is the distance between cell boundaries               ( dx = r-(R1+R2) ). This means that at φ = 1, P2P is done on               cells with boundaries closer than the average smoothing radius;               at φ = 0.5, P2P is done on cells closer than two times the               smoothing radius; at φ = 0.25, P2P is done on cells closer than               four times the smoothing radius.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-relaxation/#FLOWVPM.Relaxation","page":"Relaxation Scheme","title":"FLOWVPM.Relaxation","text":"`Relaxation(relax, nsteps_relax, rlxf)`\n\nDefines a relaxation method implemented in the function relax(rlxf::Real, p::Particle) where rlxf is the relaxation factor between 0 and 1, with 0 == no relaxation, and 1 == full relaxation. The simulation is relaxed every nsteps_relax steps.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-relaxation/#FLOWVPM.relax_pedrizzetti","page":"Relaxation Scheme","title":"FLOWVPM.relax_pedrizzetti","text":"`relax_Pedrizzetti(rlxf::Real, p::Particle)`\n\nRelaxation scheme where the vortex strength is aligned with the local vorticity.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-relaxation/#FLOWVPM.relax_correctedpedrizzetti","page":"Relaxation Scheme","title":"FLOWVPM.relax_correctedpedrizzetti","text":"`relax_correctedPedrizzetti(rlxf::Real, p::Particle)`\n\nRelaxation scheme where the vortex strength is aligned with the local vorticity. This version fixes the error in Pedrizzetti's relaxation that made the strength to continually decrease over time. See notebook 20200921 for derivation.\n\n\n\n\n\n","category":"function"},{"location":"examples/wing-4p2aoa/#simple_wing","page":"Basics","title":"Simple Wing","text":"","category":"section"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-particles06.png\" alt=\"Pic here\" style=\"width: 49%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-n100-00.png\" alt=\"Pic here\" style=\"width: 49%;\"/>\n</center>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"In this example we simulate a 45^circ swept-back wing at an angle of attack of 42^circ. In the process we exemplify the basic structure of simulations, which is always the same, no matter how complex the simulation might be. The structure consists of six steps:","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(1) Vehicle Definition: Generate the geometry of the vehicle and declare each vehicle subsystem in a FLOWUnsteady.VLMVehicle object","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(2) Maneuver Definition: Generate functions that prescribe the kinematics of the vehicle and specify the control inputs for tilting and rotor subsystems in a FLOWUnsteady.KinematicManeuver object","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(3) Simulation Definition: A FLOWUnsteady.Simulation object is generated stating the vehicle, maneuver, and total time and speed at which to perform the maneuver","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(4) Monitors Definitions: Functions are generated for calculating, monitoring, and outputting different metrics throughout the simulation","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(5) Run Simulation: Call to FLOWUnsteady.run_simulation","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(6) Viz and Postprocessing: The simulation is visualized in Paraview and results are postprocessed","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"While in this example we show the basic structure without much explanation, in subsequent examples we will dive into the details and options of each step (which are also listed in the API Guide).","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"#=##############################################################################\n# DESCRIPTION\n    45° swept-back wing at an angle of attack of 4.2°. This wing has an aspect\n    ratio of 5.0, a RAE 101 airfoil section with 12% thickness, and no dihedral,\n    twist, nor taper. This test case matches the experimental setup of Weber,\n    J., and Brebner, G., “Low-Speed Tests on 45-deg Swept-Back Wings, Part I,”\n    Tech. rep., 1951. The same case is used in a VLM calculation in Bertin's\n    Aerodynamics for Engineers, Example 7.2, pp. 343.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Feb 2023\n  * Last updated    : Feb 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\nrun_name        = \"wing-example\"            # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\nAOA             = 4.2                       # (deg) angle of attack\nmagVinf         = 49.7                      # (m/s) freestream velocity\nrho             = 0.93                      # (kg/m^3) air density\nqinf            = 0.5*rho*magVinf^2         # (Pa) static pressure\n\nVinf(X, t)      = magVinf*[cosd(AOA), 0.0, sind(AOA)]  # Freestream function\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\nb               = 2.489                     # (m) span length\nar              = 5.0                       # Aspect ratio b/c_tip\ntr              = 1.0                       # Taper ratio c_tip/c_root\ntwist_root      = 0.0                       # (deg) twist at root\ntwist_tip       = 0.0                       # (deg) twist at tip\nlambda          = 45.0                      # (deg) sweep\ngamma           = 0.0                       # (deg) dihedral\n\n# Discretization\nn               = 50                        # Number of spanwise elements per side\nr               = 10.0                      # Geometric expansion of elements\ncentral         = false                     # Whether expansion is central\n\n# NOTE: A geometric expansion of 10 that is not central means that the last\n#       element is 10 times wider than the first element. If central, the\n#       middle element is 10 times wider than the peripheral elements.\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Time parameters\nwakelength      = 2.75*b                    # (m) length of wake to be resolved\nttot            = wakelength/magVinf        # (s) total simulation time\nnsteps          = 200                       # Number of time steps\n\n# VLM and VPM parameters\np_per_step      = 1                         # Number of particle sheds per time step\n\nlambda_vpm      = 2.0                       # VPM core overlap\nsigma_vpm_overwrite = lambda_vpm * magVinf * (ttot/nsteps)/p_per_step # Smoothing core size\nsigma_vlm_solver= -1                        # VLM-on-VLM smoothing radius (deactivated with <0)\nsigma_vlm_surf  = 0.05*b                    # VLM-on-VPM smoothing radius\n\nshed_starting   = true                      # Whether to shed starting vortex\n\n\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate wing\nwing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;\n                        twist_tip=twist_tip, n=n, r=r, central=central);\n\n# NOTE: `FLOWVLM.simpleWing` is an auxiliary function in FLOWVLM for creating a\n#       VLM wing with constant sweep, dihedral, and taper ratio, and a linear\n#       twist between the root and the wing tips\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Wing\", wing)\n\nvlm_system = system;                        # System solved through VLM solver\nwake_system = system;                       # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            vlm_system=vlm_system,\n                            wake_system=wake_system\n                         );\n\n# NOTE: `FLOWUnsteady.VLMVehicle` creates a vehicle made out of multiple VLM and\n#       rotor subsystems. The argument `system` represents the vehicle as a\n#       whole which will be translated and rotated with the kinematics\n#       prescribed by the maneuver. The subsystem `vlm_system` will be solved\n#       with the VLM solver. The subsystems `rotor_systems` are solved with\n#       blade elements (none in this case). The subsystem `wake_system` will\n#       shed the VPM wake.\n\n\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n\nVvehicle(t) = zeros(3)                      # Translational velocity of vehicle over time\nanglevehicle(t) = zeros(3)                  # Angle of the vehicle over time\n\nangle = ()                                  # Angle of each tilting system (none)\nRPM = ()                                    # RPM of each rotor system (none)\n\nmaneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time\n#       (a vector with inclination angles with respect to each axis of the\n#       global coordinate system). `angle` defines the tilting angle of each\n#       tilting system over time (none in this case). `RPM` defines the RPM of\n#       each rotor system over time (none in this case).\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled up by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n\n\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = 0.0                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\n                                            # Maximum number of particles\nmax_particles = (nsteps+1)*(vlm.get_m(vehicle.vlm_system)*(p_per_step+1) + p_per_step)\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\n# NOTE: Monitors are functions that are called at every time step to perform\n#       some secondary computation after the solution of that time step has been\n#       obtained. In this case, the wing monitor uses the circulation and\n#       induced velocities to compute aerodynamic forces and decompose them\n#       into lift and drag. The monitor then plots these forces at every time\n#       step while also saving them under a CSV file in the simulation folder.\n\n# Generate function that calculates aerodynamic forces\n# NOTE: We exclude skin friction since we want to compare to the experimental\n#       data reported in Weber 1951 that was measured with pressure taps\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=false,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\nD_dir = [cosd(AOA), 0.0, sind(AOA)]         # Direction of drag\nL_dir = uns.cross(D_dir, [0,1,0])           # Direction of lift\n\nfigs, figaxs = [], []                       # Figures generated by monitor\n\n# Generate wing monitor\nmonitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"wing monitor\",\n                                            );\n\n\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    sigma_vlm_solver=sigma_vlm_solver,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_vlm_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitor_wing,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_Wing_vlm...vtk\")\n    files *= \";\"*run_name*\"_pfield...xmf;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~3 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"As the simulation runs, you will see the monitor (shown below) plotting the lift and drag coefficients over time along with the loading distribution. For comparison, here we have also added the experimental measurements reported by Weber and Brebner, 1951.","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-simmonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":" Experimental FLOWUnsteady Error\nC_L 0.238 0.23506 1.234%\nC_D 0.005 0.00501 0.143%","category":"page"},{"location":"examples/wing-4p2aoa/","page":"Basics","title":"Basics","text":"info: Paraview visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...). To open in Paraview: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"visualization/#Visualization-Guide","page":"Visualization","title":"Visualization Guide","text":"","category":"section"},{"location":"visualization/#What-NOT-to-do","page":"Visualization","title":"What NOT to do","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Unfortunately, the first thing that ParaView shows when you open a particle field is a \"scatter plot\" full of confusing colors like this:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-rainbow00-bad00.jpg\"\n    alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Not surprisingly, the VPM literature is full of these visualizations, which provide very little information about the simulation. Poor colormap aside, why is this a bad visualization? Even though we are coloring the strengths of the particles, one must remember that the particle strength boldsymbolGamma is the integral of the vorticity over the volume that is discretized by the particle, boldsymbolGamma = intlimits_mathrmVol boldsymbolomega mathrmdV. This is equivalent to the average vorticity times the volume, boldsymbolGamma = overlineboldsymbolomega mathrmVol, which means that the particle strength is proportional to the volume that it discretizes. Thus, the particle strength has no physical significance, but is purely a numerical artifact. (In fact, boldsymbolGamma are nothing more than the coefficients of the radial basis function that reconstructs the vorticity field as overlineboldsymbolomegaleft( mathbfxright) approx sumlimits_p boldsymbolGamma_p zeta_sigma_p(mathbfx-mathbfx_p).)","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Another VPM visualization that is commonly found in the literature simply shows the position of the particles:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-dots00-bad00.jpg\"\n    alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Why is this a bad visualization? Even though its intent is to depict the flow field taking advantage that the particles follow streamlines and vortical structures, what we are actually visualizing is the spatial discretization. After all, we are just looking at the position of the computational elements. Here is an equivalent visualization of the computational elements in a mesh-based simulation of the same rotor in hover:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-mesh00.png\"\n    alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Not very insightful, is it?","category":"page"},{"location":"visualization/#What-we-recommend","page":"Visualization","title":"What we recommend","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"In order to correctly visualize the flow field that is predicted by the VPM solver, one must reconstruct the vorticity field using the particles as a radial basis function and compute the velocity field using the Biot-Savart law. This can be computationally intensive and is not a streamlined process.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Alternatively, a quick visualization that sheds insights into both the flow field and the discretization is to make glyphs that point in the direction of boldsymbolGamma (arrows scaled by magnitude), thus forming the vortex lines:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-glyph02.jpg\"\n    alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443-low-glyph01.jpg\"\n    alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"This type of visualization has three advantages:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"It clearly reveals the vortical structure (vortex lines) in a quick glimpse\nOne can envision the velocity field around the vortex lines using the right hand rule (Biot-Savart law shown below)\nAdding small points at the position of each particle gives us an idea of the spatial resolution around vortices.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-particle01.png\"\n    alt=\"Pic here\" style=\"width: 80%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"info: Glyph Visualization\nA .pvsm file with a glyph visualization of the particle field is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"visualization/#Fluid-domain","page":"Visualization","title":"Fluid domain","text":"","category":"section"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"While the \"glyph\" visualization shown above uses the native variables that are computed and outputted by the VPM (boldsymbolGamma_p and mathbfx_p), the full fluid domain can be computed from the particle field in postprocessing. This is done using the particles as a radial basis function to construct a continuous and analytical vorticity field boldsymbolomega(mathbfx), and the Biot-Savart law is used to obtain a continuous and analytical velocity field mathbfu(mathbfx). Since boldsymbolomega(mathbfx) and mathbfu(mathbfx) are analytical functions, their values and their derivatives can be calculated anywhere in space.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"FLOWUnsteady provides the function uns.computefluiddomain that reads a simulation and process it to generate its fluid domain. See the Rotor in Hover tutorial for an example on how to use uns.computefluiddomain.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Whenever reporting results, we recommend showing the vortex elements (glyph visualization) and the fluid domain side by side to give a clear idea of the spatial resolution and the resulting flow field (see example below), which is custom in conventional mesh-based CFD.","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-highfidelity00.png\"\n    alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/visualization-meshbased00.png\"\n      alt=\"Pic here\" style=\"width: 85%;\"/>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<br><br>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"Here is an example of a simulation superimposing the particle field and the resulting fluid domain:","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:72%;\"\n        src=\"https://www.youtube.com/embed/Bf4pIt7oi5k?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"visualization/","page":"Visualization","title":"Visualization","text":"info: Volume Rendering\nA .pvsm file with a volume rendering of the vorticity field is   available here:   LINK   (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then   select \"Search files under specified directory\" and point it to the   folder where the simulation was saved.","category":"page"},{"location":"api/flowunsteady-vehicle-types/#vehicle_types","page":"Vehicle types","title":"Vehicle types","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-types/","page":"Vehicle types","title":"Vehicle types","text":"FLOWUnsteady.UVLMVehicle\nFLOWUnsteady.VLMVehicle\nFLOWUnsteady.QVLMVehicle","category":"page"},{"location":"api/flowunsteady-vehicle-types/#FLOWUnsteady.UVLMVehicle","page":"Vehicle types","title":"FLOWUnsteady.UVLMVehicle","text":"UVLMVehicle{N, M, R}(system; tilting_systems, rotors_systems,\n                                        vlm_system, wake_system, grids)\n\nType handling all geometries and subsystems that define a vehicle made out of FLOWVLM components (Wing, WingSystem, Rotor).\n\nARGUMENTS\n\nsystem::FLOWVLM.WingSystem:        System of all FLOWVLM objects. This system                                   is considered as the entire vehicle. Not all                                   components in this system will be solved,                                   but they will all be rotated and translated                                   according to the maneuver.\n\nOPTIONAL ARGUMENTS\n\ntilting_systems::NTuple{N, FLOWVLM.WingSystem}:   Tuple of all FLOWVLM                                   tilting objects, where tilting_systems[i]                                   contains the i-th FLOWVLM system of lifting                                   surfaces and rotors that tilt together.\nrotors_systems::NTuple{M, Array{vlm.Rotor}}:   Tuple of groups of Rotors                                   that share a common RPM.\nvlm_system::FLOWVLM.WingSystem:    System of all FLOWVLM objects to be solved                                   through the VLM solver.\nwake_system::FLOWVLM.WingSystem:   System of all FLOWVLM objects that will                                   shed a VPM wake.\ngrids::Array{gt.GridTypes}:         Array of grids that will be translated and                                   rotated along with system.\n\nState variables\n\nV::Vector                   : Current vehicle velocity\nW::Vector                   : Current vehicle angular velocity\nprev_data::Array{Any}       : Information about previous step\ngrid_O::Vector{Vector}       : Origin of every grid\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-vehicle-types/#FLOWUnsteady.VLMVehicle","page":"Vehicle types","title":"FLOWUnsteady.VLMVehicle","text":"Alias for FLOWUnsteady.UVLMVehicle\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-vehicle-types/#FLOWUnsteady.QVLMVehicle","page":"Vehicle types","title":"FLOWUnsteady.QVLMVehicle","text":"QVLMVehicle{N, M, R}(system; optargs...)\n\nSame than FLOWUnsteady.UVLMVehicle but replacing the VPM wake with a semi-infinite rigid VLM wake, making the simulation quasi-ssteady.\n\nNOTE: For the solver to work correctly, all components in wake_system (if any) need to be also components of vlm_system.\n\nNOTE 2: It is recommended that wake_system doesn't include any Rotor object. Otherwise, blades will generate a wake going straight out of every blade trailing edge pointing oposite to the direction of rotation instead of generating a streamtube.\n\n\n\n\n\n","category":"type"},{"location":"examples/wing-aoasweep/#AOA-Sweep","page":"AOA Sweep","title":"AOA Sweep","text":"","category":"section"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"Using the same vehicle, maneuver, and simulation defined in the     previous section, we now run a sweep of the angle of attack.","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    AOA sweep on 45° swept-back wing\n=###############################################################################\nimport FLOWUnsteady: cross, dot, norm, plt, @L_str\n\nAOAs        = [0, 2.1, 4.2, 6.3, 8.4, 10.5, 12] # (deg) angles of attack\nXac         = [0.25*b/ar, 0, 0]             # (m) aerodynamic center for moment calculation\n\n# Results are stored in these arrays\nCLs, CDs    = [], []                        # Lift and drag at each angle of attack\nrolls, pitchs, yaws = [], [], []            # Rolling, pitching, and yawing moment\n\nls, ds      = [], []                        # Load and drag distributions\nspanposs    = []                            # Spanwise positions for load distributions\n\n\n# ----------------- AOA SWEEP --------------------------------------------------\nfor AOA in AOAs\n\n    println(\"\\n\\n Running AOA = $(AOA) deg\")\n\n    # ------------- RUN SIMULATION ----------------\n\n    # Freestream function\n    Vinf(X, t) = magVinf*[cosd(AOA), 0.0, sind(AOA)]\n\n    # Define wing monitor with new reference freestream direction\n    Shat = [0, 1, 0]                            # Spanwise direction\n    Dhat = [cosd(AOA), 0.0, sind(AOA)]          # Direction of drag\n    Lhat = cross(Dhat, Shat)                    # Direction of lift\n\n    # Generate wing monitor\n    monitor = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                                rho, qinf, nsteps;\n                                                calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                                L_dir=Lhat,\n                                                D_dir=Dhat,\n                                                save_path=nothing,\n                                                disp_plot=false\n                                                )\n\n    # Run simulation\n    pfield = uns.run_simulation(simulation, nsteps;\n                                    # SIMULATION OPTIONS\n                                    Vinf=Vinf,\n                                    rho=rho,\n                                    # SOLVERS OPTIONS\n                                    p_per_step=p_per_step,\n                                    max_particles=max_particles,\n                                    sigma_vlm_solver=sigma_vlm_solver,\n                                    sigma_vlm_surf=sigma_vlm_surf,\n                                    sigma_rotor_surf=sigma_vlm_surf,\n                                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                                    shed_starting=shed_starting,\n                                    extra_runtime_function=monitor,\n                                    # OUTPUT OPTIONS\n                                    save_path=nothing,\n                                    v_lvl=1, verbose_nsteps=60\n                                    )\n\n    # ------------- POST-PROCESSING ---------------\n\n    # Integrate total lift and drag\n    L = sum(wing.sol[\"L\"])\n    D = sum(wing.sol[\"D\"])\n\n    # Lift and drag coefficients\n    CL = norm(L) / (qinf*b^2/ar)\n    CD = norm(D) / (qinf*b^2/ar)\n\n    # Control point of each element\n    Xs = [vlm.getControlPoint(wing, i) for i in 1:vlm.get_m(wing)]\n\n    # Force of each element\n    Fs = wing.sol[\"Ftot\"]\n\n    # Integrate the total moment with respect to aerodynamic center\n    M = sum( cross(X - Xac, F) for (X, F) in zip(Xs, Fs) )\n\n    # Integrated moment decomposed into rolling, pitching, and yawing moments\n    lhat = Dhat                   # Rolling direction\n    mhat = Shat                   # Pitching direction\n    nhat = Lhat                   # Yawing direction\n\n    roll = dot(M, lhat)\n    pitch = dot(M, mhat)\n    yaw = dot(M, nhat)\n\n    # Sectional loading (in vector form) at each control point\n    fs = wing.sol[\"ftot\"]\n\n    # Decompose vectors into lift and drag distribution\n    l = [ dot(f, Lhat) for f in fs ]\n    d = [ dot(f, Dhat) for f in fs ]\n\n    # Span position of each control point\n    spanpos = [ dot(X, Shat) / (b/2) for X in Xs ]\n\n    # Store results\n    push!(CLs, CL)\n    push!(CDs, CD)\n\n    push!(rolls, roll)\n    push!(pitchs, pitch)\n    push!(yaws, yaw)\n\n    push!(spanposs, spanpos)\n    push!(ls, l)\n    push!(ds, d)\n\nend\n\n","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~15 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"Check examples/wing/wing_aoasweep.jl to see how to postprocess and plot the results as shown below.","category":"page"},{"location":"examples/wing-aoasweep/","page":"AOA Sweep","title":"AOA Sweep","text":"<center>\n    <br><b>Spanwise loading distribution</b>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-sweep-loading.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Vehicle lift and drag</b>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-sweep-CLCD.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n\n    <br><br><b>Pitching moment</b><br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//wing-example-sweep-Cm.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-J040/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//apc10x7ccblongwake_J035_00cont03_img1_00.gif\" alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"In this example we first simulate an APC Thin-Electric 10x7 propeller operating in cruise conditions. Along the way, we demonstrate the basics of how to set up and run a rotor simulation.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"Rotors are generated through the function FLOWUnsteady.generate_rotor, which can receive either a set of parameters that define the rotor geometry (like twist/chord/sweep distributions, etc), or it can read the rotor geometry from a file. FLOWunsteady provides a prepopulated database of airfoil and rotor geometries to automate the generation of rotors, which is found under database/. This database can be accessed through the variable FLOWUnsteady.default_database. Alternatively, users can define their own database with custom rotors and airfoils.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"The following slides describe the structure of the database, using a DJI rotor as an example:","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"    <div style=\"position:relative;padding-top:50%;\">\n        <iframe style=\"position:absolute;left:0;top:0;height:100%;width:80%;\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vRsYbuuMFQdc05NRrQ3Db0RT4XKKoxEYDiUi0MpW58W6A-pp0sDHQI9mVqNFagPtQ/embed?start=true&loop=true&delayms=3000\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n    </div>\n    <br><br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"In this simulation we exemplify the following:","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"How to generate a rotor with uns.generate_rotor\nHow to generate a rotor monitor with uns.generate_monitor_rotors\nHow to set up and run a rotor simulation.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of an APC Thin-Electric 10x7 propeller (two-bladed rotor, 10-inch\n    diameter).\n\n    This example replicates the experiment and simulation described in McCrink &\n    Gregory (2017), \"Blade Element Momentum Modeling of Low-Reynolds Electric\n    Propulsion Systems.\"\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\nimport FLOWVPM as vpm\n\nrun_name        = \"propeller-example\"       # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n\n# Rotor geometry\nrotor_file      = \"apc10x7.csv\"             # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 0.0                       # (deg) collective pitch of blades\nCW              = false                     # Clock-wise rotation\nxfoil           = true                      # Whether to run XFOIL\nncrit           = 9                         # Turbulence criterion for XFOIL\n\n# NOTE: If `xfoil=true`, XFOIL will be run to generate the airfoil polars used\n#       by blade elements before starting the simulation. XFOIL is run\n#       on the airfoil contours found in `rotor_file` at the corresponding\n#       local Reynolds and Mach numbers along the blade.\n#       Alternatively, the user can provide pre-computer airfoil polars using\n#       `xfoil=false` and pointing to polar files through `rotor_file`.\n\n# Discretization\nn               = 20                        # Number of blade elements per blade\nr               = 1/5                       # Geometric expansion of elements\n\n# NOTE: Here a geometric expansion of 1/5 means that the spacing between the\n#       tip elements is 1/5 of the spacing between the hub elements. Refine the\n#       discretization towards the blade tip like this in order to better\n#       resolve the tip vortex.\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n\n# Operating conditions\nRPM             = 9200                      # RPM\nJ               = 0.4                       # Advance ratio Vinf/(nD)\nAOA             = 0                         # (deg) Angle of attack (incidence angle)\n\nrho             = 1.225                     # (kg/m^3) air density\nmu              = 1.81e-5                   # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\n\nmagVinf         = J*RPM/60*(2*R)\nVinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector\n\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number\nMatip           = 2*pi*RPM/60*R / speedofsound      # Tip Mach number\n\nprintln(\"\"\"\n    RPM:    $(RPM)\n    Vinf:   $(Vinf(zeros(3), 0)) m/s\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n# VehicleType   = uns.QVLMVehicle           # Quasi-steady solver\nconst_solution  = VehicleType==uns.QVLMVehicle  # Whether to assume that the\n                                                # solution is constant or not\n# Time parameters\nnrevs           = 4                         # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = const_solution ? 2 : nrevs*nsteps_per_rev # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 2                         # Sheds per time step\nshed_starting   = true                      # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nmax_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\n\n# Regularization\nsigma_rotor_surf= R/40                      # Rotor-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\n\n# Rotor solver\nvlm_rlx         = 0.7                       # VLM relaxation <-- this also applied to rotors\nhubtiploss_correction = vlm.hubtiploss_nocorrection # Hub and tip loss correction\n\n# VPM solver\nvpm_viscous     = vpm.Inviscid()            # VPM viscous diffusion scheme\n\n# NOTE: In most practical situations, open rotors operate at a Reynolds number\n#       high enough that viscous diffusion in the wake is negligible.\n#       Hence, it does not make much of a difference whether we run the\n#       simulation with viscous diffusion enabled or not.\n\n\nif VehicleType == uns.QVLMVehicle\n    # NOTE: If the quasi-steady solver is used, this mutes warnings regarding\n    #       potential colinear vortex filaments. This is needed since the\n    #       quasi-steady solver will probe induced velocities at the lifting\n    #       line of the blade\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, blade_r=r,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        ncrit=ncrit,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        verbose_xfoil=false,\n                                        plot_disc=true\n                                        );\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Rotor\", rotor)\n\nrotors = [rotor];                           # Defining this rotor as its own system\nrotor_systems = (rotors, );                 # All systems of rotors\n\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    vlm.addwing(wake_system, \"Rotor\", rotor)\nend\n\nvehicle = VehicleType(   system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n# NOTE: Through the `rotor_systems` keyword argument to `uns.VLMVehicle` we\n#       have declared any systems (groups) of rotors that share a common RPM.\n#       We will later declare the control inputs to each rotor system when we\n#       define the `uns.KinematicManeuver`.\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = zeros(3)\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time.\n#       `angle` defines the tilting angle of each tilting system over time.\n#       `RPM` defines the RPM of each rotor system over time.\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\n\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\nfigs, figaxs = [], []                       # Figures generated by monitor\n\n# Generate rotor monitor\nmonitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                            t_scale=RPM/60,        # Scaling factor for time in plots\n                                            t_lbl=\"Revolutions\",   # Label for time axis\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"rotor monitor\",\n                                            )\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho, mu=mu, sound_spd=speedofsound,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    vpm_viscous=vpm_viscous,\n                    sigma_vlm_surf=sigma_rotor_surf,\n                    sigma_rotor_surf=sigma_rotor_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    vlm_rlx=vlm_rlx,\n                    hubtiploss_correction=hubtiploss_correction,\n                    shed_unsteady=shed_unsteady,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitor_rotor,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_pfield...xmf;\")\n    for bi in 1:B\n        global files\n        files *= run_name*\"_Rotor_Blade$(bi)_loft...vtk;\"\n        files *= run_name*\"_Rotor_Blade$(bi)_vlm...vtk;\"\n    end\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~2 minutes on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"As the simulation runs, you will see the monitor shown below plotting the blade loading along with thrust and torque coefficients and propulsive efficiency.","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-example-simmonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-J040/","page":"Basics","title":"Basics","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"api/flowunsteady-simulation/#(3)-Simulation-Definition","page":"(3) Simulation Definition","title":"(3) Simulation Definition","text":"","category":"section"},{"location":"api/flowunsteady-simulation/","page":"(3) Simulation Definition","title":"(3) Simulation Definition","text":"FLOWUnsteady.Simulation\nFLOWUnsteady.save_vtk","category":"page"},{"location":"api/flowunsteady-simulation/#FLOWUnsteady.Simulation","page":"(3) Simulation Definition","title":"FLOWUnsteady.Simulation","text":"Simulation{V<:AbstractVehicle, M<:AbstractManeuver, R<:Real}(vehicle::V,\n                        maneuver::M, Vref::R, RPMref::R, ttot::R, optargs...)\n\nSimulation interface. This type carries the simulation's options and connects vehicle and maneuver together.\n\nARGUMENTS\n\nvehicle                 : Vehicle\nmaneuver                : Maneuver\nVref                    : Reference velocity for the maneuver\nRPMref                  : Reference RPM for the maneuver\nttot                    : Total time in which to perform the maneuver\n\nOPTIONAL ARGUMENTS\n\nVinit = zeros(3)        : Initial vehicle velocity\nWinit = zeros(3)        : Initial vehicle angular velocity\n\nState variables\n\nt::Real                 : Time of current step\nnt::Int                 : Current time step number\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-simulation/#FLOWUnsteady.save_vtk","page":"(3) Simulation Definition","title":"FLOWUnsteady.save_vtk","text":"save_vtk(self::AbstractVehicle, prefix; path=\"\", optargs...)\n\nOutput VTK files with vehicle geometry and solution fields.\n\n\n\n\n\nsave_vtk(sim::Simulation, prefix; path=\"\", save_wopwopin=false, optargs...)\n\nOutput VTK files with vehicle geometry and solution fields. The file names will have the prefix prefix, and will be saved in the directory path. If save_wopwopin=true, it will also generate PSU-WOPWOP input files that can be used to run the acoustic analysis (see run_noise_wopwop).\n\n\n\n\n\n","category":"function"},{"location":"examples/rotorhover-acoustics/#Aeroacoustic-Noise","page":"Aeroacoustics","title":"Aeroacoustic Noise","text":"","category":"section"},{"location":"examples/rotorhover-fdom/#rotorfdom","page":"Fluid Domain","title":"Fluid Domain","text":"","category":"section"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//dji9443-fdom00.jpeg\" alt=\"Pic here\" style=\"width: 75%;\"/>\n</center>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<br>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"The full fluid domain can be computed in a postprocessing step from the particle field. This is possible because the particle field is a radial basis function that constructs the vorticity field, and the velocity field can be recovered from vorticity through the Biot-Savart law.","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"Here we show how to use uns.computefluiddomain to read a simulation and process it to generate its fluid domain.","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"#=##############################################################################\n    Computes the fluid domain of DJI 9443 simulation using a volumetric domain.\n    This is done probing the velocity and vorticity that the particle field\n    induces at each node of a Cartesian grids.\n\n    NOTE: The fluid domain generated here does not include the freestream\n            velocity, which needs to be added manually inside ParaView (if any).\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWUnsteady: vpm, gt, dot, norm\n\n# --------------- INPUTS AND OUTPUTS -------------------------------------------\n# INPUT OPTIONS\nsimulation_name = \"rotorhover-example-midhigh00\"               # Simulation to read\nread_path       = \"/home/edoalvar/simulationdata202330/\"*simulation_name # Where to read simulation from\n\npfield_prefix   = \"singlerotor_pfield\"      # Prefix of particle field files to read\nstaticpfield_prefix = \"singlerotor_staticpfield\" # Prefix of static particle field files to read\n\nnums            = [719]              # Time steps to process\n\n# OUTPUT OPTIONS\nsave_path       = joinpath(read_path, \"..\", simulation_name*\"-fdom\")  # Where to save fluid domain\noutput_prefix   = \"singlerotor\"             # Prefix of output files\nprompt          = true                      # Whether to prompt the user\nverbose         = true                      # Enable verbose\nv_lvl           = 0                         # Verbose indentation level\n\n\n# -------------- PARAMETERS ----------------------------------------------------\n# Simulation information\nR               = 0.12                      # (m) rotor radius\nAOA             = 0.0                       # (deg) angle of attack or incidence angle\n\n# Grid\nL               = R                         # (m) reference length\ndx, dy, dz      = L/50, L/50, L/50          # (m) cell size in each direction\nPmin            = L*[-0.50, -1.25, -1.25]   # (m) minimum bounds\nPmax            = L*[ 2.00,  1.25,  1.25]   # (m) maximum bounds\nNDIVS           = ceil.(Int, (Pmax .- Pmin)./[dx, dy, dz])  # Number of cells in each direction\nnnodes          = prod(NDIVS .+ 1)          # Total number of nodes\n\nOaxis           = gt.rotation_matrix2(0, 0, AOA)    # Orientation of grid\n\n# VPM settings\nmaxparticles    = Int(1.0e6 + nnodes)         # Maximum number of particles\nfmm             = vpm.FMM(; p=4, ncrit=50, theta=0.4, phi=0.3) # FMM parameters (decrease phi to reduce FMM noise)\nscale_sigma     = 1.00                      # Shrink smoothing radii by this factor\nf_sigma         = 0.5                       # Smoothing of node particles as sigma = f_sigma*meansigma\n\nmaxsigma        = L/10                      # Particles larger than this get shrunk to this size (this helps speed up computation)\nmaxmagGamma     = Inf                       # Any vortex strengths larger than this get clipped to this value\n\ninclude_staticparticles = true              # Whether to include the static particles embedded in the solid surfaces\n\nother_file_prefs = include_staticparticles ? [staticpfield_prefix] : []\nother_read_paths = [read_path for i in 1:length(other_file_prefs)]\n\nif verbose\n    println(\"\\t\"^(v_lvl)*\"Fluid domain grid\")\n    println(\"\\t\"^(v_lvl)*\"NDIVS =\\t$(NDIVS)\")\n    println(\"\\t\"^(v_lvl)*\"Number of nodes =\\t$(nnodes)\")\nend\n\n# --------------- PROCESSING SETUP ---------------------------------------------\nif verbose\n    println(\"\\t\"^(v_lvl)*\"Getting ready to process $(read_path)\")\n    println(\"\\t\"^(v_lvl)*\"Results will be saved under $(save_path)\")\nend\n\n# Create save path\nif save_path != read_path\n    gt.create_path(save_path, prompt)\nend\n\n\n# Generate function to process the field clipping particle sizes\npreprocessing_pfield = uns.generate_preprocessing_fluiddomain_pfield(maxsigma, maxmagGamma;\n                                                                        verbose=verbose, v_lvl=v_lvl+1)\n\n# --------------- PROCESS SIMULATION -------------------------------------------\n\nnthreads        = 1                         # Total number of threads\nnthread         = 1                         # Number of this thread\ndnum = floor(Int, length(nums)/nthreads)    # Number of time steps per thread\nthreaded_nums = [view(nums, dnum*i+1:(i<nthreads-1 ? dnum*(i+1) : length(nums))) for i in 0:nthreads-1]\n\nfor these_nums in threaded_nums[nthread:nthread]\n\n     uns.computefluiddomain(    Pmin, Pmax, NDIVS,\n                                maxparticles,\n                                these_nums, read_path, pfield_prefix;\n                                Oaxis=Oaxis,\n                                fmm=fmm,\n                                f_sigma=f_sigma,\n                                save_path=save_path,\n                                file_pref=output_prefix, grid_names=[\"_fdom\"],\n                                other_file_prefs=other_file_prefs,\n                                other_read_paths=other_read_paths,\n                                userfunction_pfield=preprocessing_pfield,\n                                verbose=verbose, v_lvl=v_lvl)\n\nend","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~1 minute on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/rotorhover-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"info: ParaView Visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"theory/rvpm/#Reformulated-VPM","page":"Reformulated VPM","title":"Reformulated VPM","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The following is an excerpt from  E. J. Alvarez & A. Ning (2022), \"Meshless Large Eddy Simulation of Rotor-Wing Interactions Through the Reformulated Vortex Particle Method,\" (in review).","category":"page"},{"location":"theory/rvpm/#Vorticity-Navier-Stokes","page":"Reformulated VPM","title":"Vorticity Navier-Stokes","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In recent work[1][2], a new formulation of the vortex particle method (VPM) has been derived from the LES-filtered Navier-Stokes equations. The new method, referred to as the reformulated VPM or rVPM, is an LES that is both numerically stable and meshless, and is able to accurately resolve mean and fluctuating large-scale features of turbulent flow with minimal computational effort. Hereby we concisely summarize the governing equations of the reformulated VPM, and the reader is referred to Ref.[1] and the doctoral dissertation[2] accompanying this work for a detailed derivation of the method.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The reformulated VPM uses a Lagrangian scheme to solve the vorticity form of the LES-filtered Navier-Stokes equations","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n        fracpartial overline omega_i partial t\n        + overline u_j  fracpartial overline omega_i partial x_j\n     =\n        overline omega_j  fracpartial overline u_i partial x_j\n    +\n        nu nabla^2 overline omega_i  -\n        fracpartial T_ijpartial x_j +\n        fracpartial T_ijpartial x_j\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where the bar denotes the filter operator,[a] and T_ij equiv overline u_i omega_j  - overline u_i   overline omega_j  is the subfilter-scale (SFS) vorticity stress capturing the interactions between large-scale dynamics and SFS dynamics. The term fracpartial T_ijpartial x_j represents the SFS contributions arising from the advective term (vorticity advection), while fracpartial T_ijpartial x_j represents the contributions arising from vortex stretching. For simplicity, Eq. (1) is written in vector notation as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n    fractextd textd t overline boldsymbolomega \n    = left( overline boldsymbolomega  cdot nabla right) overline mathbfu  +\n    nu nabla^2 overline boldsymbolomega \n    - mathbfE_mathrmadv - mathbfE_mathrmstr\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where left( mathbfE_mathrmadv right)_i equiv fracpartial T_ijpartial x_j is the SFS vorticity advection, left( mathbfE_mathrmstr right)_i equiv - fracpartial T_ijpartial x_j is the SFS vortex stretching, and the fractextd textd t operator is the linearized version of the filtered material derivative, fractextd textd t () equiv fracpartial partial t() + (overline bf u  cdot nabla)(). Notice that casting the Navier-Stokes equation into this vorticity form gets rid of all dependance on pressure. Furthermore, this equation depends on boldsymbolomega alone since bfu can be calculated directly from boldsymbolomega = nabla times bfu through the Biot-Savart law.","category":"page"},{"location":"theory/rvpm/#particlediscretization","page":"Reformulated VPM","title":"Particle Discretization","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The material derivative in Eq. (2) and the material-conservative nature of the vorticity makes the boldsymbolomega field especially well fit for a Lagrangian description. The unfiltered boldsymbolomega field is discretized with singular vortex particles of positions bf x_p and coefficients boldsymbolGamma_p (called vortex strength), approximating boldsymbolomega as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign  labeleqparticledirac\n    boldsymbolomega(bf xt) approx sum\n        limits_p boldsymbolGamma_p (t)\n            delta  (bf x - bf x_p(t))\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where delta is the Dirac delta. Applying the filter operator,","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overline boldsymbolomega  left( mathbfx right)\n     =\n        intlimits_-infty^infty\n            boldsymbolomegaleft( mathbfy right)\n            zeta_sigma(mathbfx-mathbfy)\n        mathrmdmathbfy\n      \n    approx\n        intlimits_-infty^infty\n            left(\n                sumlimits_p\n                    boldsymbolGamma_p\n                    delta (textbf y - textbf x_p)\n            right)\n            zeta_sigma(mathbfx-mathbfy)\n        mathrmdmathbfy\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"the Dirac delta collapses the integral, obtaining an approximation of the filtered vorticity field as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign  labeleqparticleblob\n        overlineboldsymbolomegaleft( mathbfxt right)\n     approx\n        sumlimits_p\n            boldsymbolGamma_p (t)\n            zeta_sigma_p(mathbfx-mathbfx_p(t))\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where zeta_sigma(mathbfx) equiv frac1sigma^3 zeta left(fracVert mathbfx Vertsigma right) is the filter kernel of width sigma and radial basis zeta. As seen in Eq. (4), the filter operator has the effect of spreading the vortex strength boldsymbolGamma_p in space, regularizing the singularity originally introduced by the Dirac delta. Thus, the filter kernel takes the role of a basis function that is used to discretize overlineboldsymbolomega through particles. We let the filter width sigma (here on called smoothing radius or core size) change in time and space according to the evolution of each individual particle. The particle field constructs a continuous vorticity field through radial basis functions as given by Eq. (4), and also a continuous velocity field by inverting the relation overlineboldsymbolomega = nabla times overlinemathbfu as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign  labeleqUreg\n        overline mathbfu left( mathbfx right)\n    =\n        - frac14pisumlimits_p g_sigma_pleft( mathbfx-mathbfx_p right)\n            fracmathbfx-mathbfx_pVertmathbfx-mathbfx_pVert^3\n            times\n            boldsymbolGamma_p\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where g_sigma is the regularizing function[3] associated with the filter kernel zeta_sigma. Hence, all fluid properties—like overlinemathbfu and its spatial derivatives—are continuous and can be computed analytically.","category":"page"},{"location":"theory/rvpm/#Governing-Equations","page":"Reformulated VPM","title":"Governing Equations","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"Similar to the process that led from Eq. (3) to Eq. (4), we use singular particles to discretize the LES-filtered vorticity equation given in Eq. (2), and arrive to the governing equations of the reformulated VPM:","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n     labeleqrvpmgedxdt\n     bullet quad\n    \n        fractextdtextdtbf x_p\n        =\n        overlinemathbfu(bf x_p)\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n       labeleqrvpmgedGammadt\n    beginsplit\n         bullet quad\n         fracmathrmd mathrmd t boldsymbolGamma_p\n        =\n            left(\n                boldsymbolGamma_p cdot nabla\n            right)\n            overlinemathbfu (bf x_p)\n            -\n            fracg + ffrac13 + f\n            left\n                left\n                    left(\n                            boldsymbolGamma_p  cdot nabla\n                        right)\n                        overlinemathbfu small (bf x_p)\n                right\n                cdot hatboldsymbolGamma_p\n            right hatboldsymbolGamma_p\n        \n         qquad qquad \n        qquad qquad quad \n            - fracC_dzeta_sigma_p (bf 0)\n            left\n                mathbfE_mathrmstr (bf x_p)\n                -\n                fracffrac13 + f\n                left(\n                    mathbfE_mathrmstr (bf x_p) cdot hatboldsymbolGamma_p\n                right) hatboldsymbolGamma_p\n            right\n    endsplit\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n       labeleqrvpmgedsigmadt\n     bullet quad\n    \n        fracmathrmd mathrmd t sigma_p\n        =\n        - left(\n            fracg + f1 + 3f\n        right)\n        fracsigma_pVert boldsymbolGamma_p Vert\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overlinemathbfu small (bf x_p)\n            right\n            cdot hatboldsymbolGamma_p\n        +\n        left(\n            fracf1 + 3f\n        right)\n        fracsigma_pVert boldsymbolGamma_p Vert\n        fracC_dzeta_sigma_p (bf 0)\n        mathbfE_mathrmstr (bf x_p) cdot hatboldsymbolGamma_p\nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign\n       labeleqrvpmgeviscous\n     bullet quad\n    \n        left(\n            fractextd textd t overline boldsymbolomega \n        right)_mathrmviscous\n        =\n        nu nabla^2 overline boldsymbolomega \nendalign","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where Eq. (6) resolves vorticity advection by convecting the particles, Eq. (7) governs the evolution of vortex strength, and Eq. (8) governs the evolution of particle size. Eq. (7) in conjunction with Eqs. (6) and (8) resolve the inviscid part of the LES-filtered vorticity Navier-Stokes equation, while the viscous part in Eq. (9) can be resolved through any of the schemes previously proposed in the literature (e.g., vortex redistribution method, particle strength exchange, or core spreading).","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The main headway of the reformulated VPM over the classic VPM is that rVPM uses the particle size, or fracmathrmd mathrmd t sigma_p, as an extra degree of freedom to reinforce conservation laws. As shown in References [1] and [2], momentum and mass conservation leads to f = 0 and g = frac15, and Eqs. (7) and (8) become","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n     bullet quad\n     fracmathrmd mathrmd t boldsymbolGamma_p\n    =\n        left(\n            boldsymbolGamma_p cdot nabla\n        right)\n        overline mathbfu  (mathbfx_p)\n        -\n        frac35\n        left\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overline mathbfu  small (mathbfx_p)\n            right\n            cdot hatboldsymbolGamma_p\n        right hatboldsymbolGamma_p\n        - fracC_dzeta_sigma_p (mathbf0)\n            mathbfE_mathrmstr (mathbfx_p)\n    \n     bullet quad\n    \n        fracmathrmd mathrmd t sigma_p\n        =\n        -\n        frac15\n        fracsigma_pVert boldsymbolGamma_p Vert\n            left\n                left(\n                        boldsymbolGamma_p  cdot nabla\n                    right)\n                    overline mathbfu  small (mathbfx_p)\n            right\n            cdot hatboldsymbolGamma_p\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"which is the formulation referred to as the \"reformulated VPM.\" Notice that when f = g = 0 and mathbfE_mathrmstr is neglected, Eqs. (7) and (8) collapse back to the classic VPM equations, making these equations a generalization of the classic method. In Reference [2] is shown that the classic VPM turns out to violate both conservation of momentum and mass when it assumes fracmathrmd mathrmd t sigma_p = 0, which explains the tendency of the classic VPM to be numerically unstable. Furthermore, notice that the rVPM equations do not require more computation than the classic VPM: when SFS effects are neglected (mathbfE_mathrmstr=0), both fracmathrmd sigma_p mathrmdt and fracmathrmd boldsymbolGamma_pmathrmd t are calculated directly and solely from vortex stretching, left( boldsymbolGamma_p cdot nabla  right) overlinemathbfu (bf x_p).","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"For an in-depth derivation of the rVPM governing equations, see Chapters 1 and 2 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/#sfsmodel","page":"Reformulated VPM","title":"Turbulence Model","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"Turning our attention back to the SFS stress tensor T_ij, the accuracy of LES hinges on the modeling of this tensor. Its divergence represents the rate at which enstrophy—a measure of rotational kinetic energy—is transferred from resolved scales to subfilter scales (diffusion) and from subfilter scales to resolved scales (backscatter). In vortex methods, the most common SFS models use variants of the Smagorinsky eddy-viscosity model formulated for the vorticity stress.[4][5] However, these models are developed on the basis of homogeneous isotropic turbulence, which makes them overly diffusive in simulations with coherent vortical structures. In Reference [1], the following anisotropic model of SFS vortex stretching is proposed:","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*  labeleqEstr\n        mathbfE_mathrmstr left( mathbfx right)\n    approx\n        sumlimits_q\n            zeta_sigma(mathbfx-mathbfx_q)\n            left(\n                boldsymbolGamma_q cdot nabla\n            right)\n            left(\n                overlinemathbfu left( mathbfx right) - overlinemathbfu left( mathbfx_q right)\n            right)\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The model coefficient C_d is calculated dynamically at the position of every particle as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*  labeleqCdGammaMLave\n        C_d\n    =\n        frac\n            left boldsymbolGamma_p cdot mathbfL right\n        \n            left boldsymbolGamma_p cdot mathbfm right\n        \nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where left cdot right denotes an integration along Lagrangian trajectories[6], and","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n    \n        mathbfm =\n            fracsigma^3zeta(0) fracpartial mathbfE_mathrmstr partial sigma (mathbfx_p)\n    \n    \n        mathbfL =\n            frac3sigma\n            left( boldsymbolGamma_p cdot nabla right)\n            left(\n                mathbfu (mathbfx_p) - overlinemathbfu (mathbfx_p)\n            right)\n            +\n            left( boldsymbolGamma_p cdot nabla right)\n            fracpartial overlinemathbfu partial sigma  (mathbfx_p)\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"This dynamic procedure is based on a simultaneous balance of enstrophy-production and derivatives between true and modeled SFS contributions. Backscatter is controlled by clipping the model coefficient to C_d=0 whenever the condition C_d boldsymbolGamma_p cdot mathbfE_mathrmstr (mathbfx_p) geq 0 is not satisfied. This results in a low-dissipation SFS model that uses vortex stretching as the physical mechanism for turbulence, which is well suited for flows with coherent vortical structures where the predominant cascade mechanism is vortex stretching.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"For an in-depth derivation of the SFS model, see Chapter 3 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/#Immersed-Vorticity","page":"Reformulated VPM","title":"Immersed Vorticity","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In order to immerse the vorticity of solid boundaries into the LES-filtered Navier-Stokes equations, the filtered vorticity field overlineboldsymbolomega(mathbfx t) is decomposed into a free-vorticity field overlineboldsymbolomega_mathrmfree(mathbfx t) and a bound-vorticity field overlineboldsymbolomega_mathrmbound(mathbfx t) as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overlineboldsymbolomega\n    =\n        overlineboldsymbolomega_mathrmfree + overlineboldsymbolomega_mathrmbound\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"Both components can be discretized with vortex particles as","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overlineboldsymbolomega (mathbfx)\n    =\n        underbrace\n            sumlimits_p boldsymbolGamma_p zeta_sigma_p left( mathbfx - mathbfx_p right)\n        _overlineboldsymbolomega_mathrmfree\n        +\n        underbrace\n            sumlimits_b boldsymbolGamma_b zeta_sigma_b left( mathbfx - mathbfx_b right)\n        _overlineboldsymbolomega_mathrmbound\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"where the particles discretizing the free-vorticity field evolve according to the rVPM governing equations, Eqs. (6) through (9), while the ones discretizing the bound-vorticity are embedded on the solid boundaries and their strength is calculated by actuator models derived in Alvarez' Dissertation,[2] Chapter 6. The velocity field is obtained by inverting the relation boldsymbolomega = nabla times mathbfu, resulting in","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"beginalign*\n        overline mathbfu left( mathbfx right)\n    =\n        underbrace\n            sumlimits_p g_sigma_pleft( mathbfx-mathbfx_p right)\n                mathbfKleft( mathbfx-mathbfx_p right)\n                times\n                boldsymbolGamma_p\n        _overlinemathbfu_mathrmfree\n        +\n        underbrace\n            sumlimits_b g_sigma_bleft( mathbfx-mathbfx_b right)\n                mathbfKleft( mathbfx-mathbfx_b right)\n                times\n                boldsymbolGamma_b\n        _overlinemathbfu_mathrmbound\nendalign*","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"which includes the velocity induced by both free and bound vorticity components, and where mathbfKleft( mathbfx right) equiv - frac14pi fracmathbfxVertmathbfxVert^3. Thus, the evolution of the free particles is influenced by the vorticity immersed at the solid boundaries, affecting their convection and vortex stretching through the velocity field induced by the bound particles.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"The immersed vorticity not only affects the evolution of existing free vorticity, but it also creates new free vorticity at the boundary through viscous diffusion. In reality, vorticity is created in the boundary layer, it builds up as it travels along the surface, and it is eventually shed off the surface either by the Kutta condition at the trailing edge, flow separation, or other turbulent mechanisms. On a slender body, the vorticity can be assumed to be shed at the trailing edge.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In most models inside FLOWUnsteady, instead of creating vorticity through the viscous diffusion equation, the immersed vorticity is shed along a prescribed trailing edge. This approach neglects the wake created by flow separation. However, the effects of flow separation on loading (like the drop in lift and increase in pressure drag on a stalled airfoil) can still be captured whenever lookup airfoil tables are used.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"compat: Recommended\nFor an in-depth discussion of the actuator line and surface models implemented in FLOWUnsteady, see Chapter 6 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/#Other-Schemes","page":"Reformulated VPM","title":"Other Schemes","text":"","category":"section"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"In the default settings of FLOWUnsteady, vortex stretching is resolved with the transposed scheme and the divergence of the vorticity field is treated through the relaxation scheme developed by Pedrizzeti.[7] The time integration of the governing equations is done through a low-storage third-order Runge-Kutta scheme. A Gaussian kernel is used as the LES filter zeta_sigma (or VPM radial basis function). Like the classic VPM, the reformulated VPM is spatially second-order accurate in the convective term when a Gaussian basis is used. Viscous diffusion is solved through the core spreading method coupled with the radial basis function interpolation approach for spatial adaptation developed by Barba.[8] This viscous scheme has second-order spatial convergence, while showing linear convergence when coupled with spatial adaptation. The fast multipole method (FMM) is used for the computation of the regularized Biot-Savart law, approximating the velocity field and vortex stretching through spherical harmonics with computational complexity mathcalO(N), where N is the number of particles. The FMM computation of vortex stretching is performed through an efficient complex-step derivative approximation,[9] implemented in a modified version of the open-source, parallelized code ExaFMM. FLOWVPM and FLOWUnsteady are implemented in the Julia language, which is a modern, high-level, dynamic programming language for high-performance computing.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"compat: Recommended\nFor an in-depth discussion of the numerical schemes implemented in FLOWUnsteady, see Chapter 4 in Alvarez' Dissertation.[2]","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[1]: E. J. Alvarez & A. Ning (2022), \"Reviving the Vortex Particle Method: A Stable Formulation for Meshless Large Eddy Simulation,\" (in review). [PDF]","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[2]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[3]: Winckelmans, G., and Leonard, A., “Contributions to Vortex Particle Methods for the Computation of Three-Dimensional Incompressible Unsteady Flows,” Journal of Computational Physics, Vol. 109, No. 2, 1993.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[4]: Winckelmans, G. S., “Some progress in large-eddy simulation using the 3D vortex particle method,” CTR Annual Research Briefs, , No. 2, 1995, pp. 391–415.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[5]: Mansfield, J. R., Knio, O. M., and Meneveau, C., “A Dynamic LES Scheme for the Vorticity Transport Equation: Formulation and a Priori Tests,” Journal of Computational Physics, Vol. 145, No. 2, 1998, pp. 693–730.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[6]: Meneveau, C., Lund, T. S., and Cabot, W. H., “A Lagrangian dynamic subgrid-scale model of turbulence,” Journal of Fluid Mechanics, Vol. 319, No. -1, 1996, p. 353.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[7]: Pedrizzetti, G., “Insight into singular vortex flows,” Fluid Dynamics Research, Vol. 10, No. 2, 1992, pp. 101–115.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[8]: Barba, L. A., Leonard, A., and Allen, C. B., “Advances in viscous vortex methods - Meshless spatial adaption based on radial basis function interpolation,” International Journal for Numerical Methods in Fluids, Vol. 47, No. 5, 2005, pp. 387–421. Also, Barba, L. A., “Vortex Method for computing high-Reynolds number Flows: Increased accuracy with a fully mesh-less formulation,” California Institute of Technology, Vol. 2004, 2004.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[9]: Alvarez, E. J., and Ning, A., “High-Fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design,” AIAA Journal, Vol. 58, No. 10, 2020, pp. 4385–4400.","category":"page"},{"location":"theory/rvpm/","page":"Reformulated VPM","title":"Reformulated VPM","text":"[a]: Let phi be a field and zeta_sigma a filter kernel with cutoff length sigma, the filter operator is defined as overlinephi left( mathbfx right) equiv intlimits_-infty^infty phi(mathbfy)zeta_sigma(mathbfx-mathbfy) mathrmdmathbfy.","category":"page"},{"location":"api/flowvpm-uj/#UJ-Scheme","page":"UJ Scheme","title":"UJ Scheme","text":"","category":"section"},{"location":"api/flowvpm-uj/","page":"UJ Scheme","title":"UJ Scheme","text":"FLOWUnsteady.vpm.Kernel\nFLOWUnsteady.vpm.UJ_direct\nFLOWUnsteady.vpm.UJ_fmm\nFLOWUnsteady.vpm.FMM","category":"page"},{"location":"api/flowvpm-uj/#FLOWVPM.Kernel","page":"UJ Scheme","title":"FLOWVPM.Kernel","text":"Kernel(zeta, g, dgdr, g_dgdr, EXAFMM_P2P, EXAFMM_L2P)\n\nArguments\n\nzeta::Function        : Basis function zeta(r).\ng::Function           : Regularizing function g(r).\ndgdr::Function        : Derivative of g(r).\ng_dgdr::Function      : Efficient evaluation of g and dgdr.\nEXAFMM_P2P::Int       : Flag for the ExaFMM P2P function to call.\nEXAFMM_L2P::Int       : Flag for the ExaFMM L2P function to call.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-uj/#FLOWVPM.UJ_direct","page":"UJ Scheme","title":"FLOWVPM.UJ_direct","text":"UJ_direct(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself by direct particle-to-particle interaction, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\nUJ_direct(source, target)\n\nCalculates the velocity and Jacobian that the field source exerts on every particle of  field target, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-uj/#FLOWVPM.UJ_fmm","page":"UJ Scheme","title":"FLOWVPM.UJ_fmm","text":"UJ_fmm(pfield)\n\nCalculates the velocity and Jacobian that the field exerts on itself through a fast-multipole approximation, saving U and J on the particles.\n\nNOTE: This method accumulates the calculation on the properties U and J of every particle without previously emptying those properties.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#Generating-components","page":"Generating components","title":"Generating components","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/#Rotor","page":"Generating components","title":"Rotor","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWunsteady uses a database of airfoil and rotor geometries to automate the generation of rotors. A prepopulated database is found in the directory under FLOWUnsteady.default_database. Alternatively, users can define their own database with custom rotors and airfoils.","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"The following slides describe the structure of the database, using the DJI 9443 rotor as an example:","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"<div style=\"position:relative;padding-top:60%;\">\n<iframe style=\"position:absolute;left:0;top:0;height:100%;width:100%;\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vRsYbuuMFQdc05NRrQ3Db0RT4XKKoxEYDiUi0MpW58W6A-pp0sDHQI9mVqNFagPtQ/embed?start=true&loop=true&delayms=3000\" frameborder=\"0\" width=\"100%\" height=\"100%\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n</div>","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"Rotors can then be generated calling any of following functions:","category":"page"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWUnsteady.generate_rotor(::String)\nFLOWUnsteady.generate_rotor(::Real, ::Real, ::Int, ::String)\nFLOWUnsteady.generate_rotor(::Real, ::Real, ::Int, ::Array{Float64,2},\n                            ::Array{Float64,2}, ::Array{Float64,2},\n                            ::Array{Float64,2},\n                            ::Array{Tuple{Float64,Array{Float64, 2},String},1})\nFLOWUnsteady.vlm.rotate","category":"page"},{"location":"api/flowunsteady-vehicle-components/#FLOWUnsteady.generate_rotor-Tuple{String}","page":"Generating components","title":"FLOWUnsteady.generate_rotor","text":"generate_rotor(rotor_file::String;\n                    data_path=FLOWUnsteady.default_database, optargs...)\n\nGenerates a FLOWVLM.Rotor reading the full rotor geometry from the rotor file rotor_file found in the database data_path.\n\n\n\n\n\n","category":"method"},{"location":"api/flowunsteady-vehicle-components/#FLOWUnsteady.generate_rotor-Tuple{Real, Real, Int64, String}","page":"Generating components","title":"FLOWUnsteady.generate_rotor","text":"generate_rotor(Rtip, Rhub, B, blade_file::String;\n                    data_path=FLOWUnsteady.default_database, optargs...)\n\nGenerates a FLOWVLM.Rotor reading the blade geometry from the blade file blade_file found in the database data_path.\n\n\n\n\n\n","category":"method"},{"location":"api/flowunsteady-vehicle-components/#FLOWUnsteady.generate_rotor-Tuple{Real, Real, Int64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Tuple{Float64, Matrix{Float64}, String}}}","page":"Generating components","title":"FLOWUnsteady.generate_rotor","text":"generate_rotor(Rtip, Rhub, B,\n                    chorddist, twistdist, sweepdist, heightdist,\n                    airfoil_contours;\n\n                    # MORE ROTOR PARAMETERS\n                    pitch=0.0,\n                    CW=true,\n\n                    # DISCRETIZATION SETTINGS\n                    n=10, blade_r=1.0,\n                    rediscretize_airfoils=true,\n                    rfl_n_lower=15, rfl_n_upper=15,\n                    spline_k=5, spline_s=0.001, spline_bc=\"extrapolate\",\n\n                    # AIRFOIL PROCESSING\n                    data_path=FLOWUnsteady.default_database,\n                    read_polar=vlm.ap.read_polar,\n                    xfoil=false,\n                    alphas=[i for i in -20:1.0:20], ncrit=9,\n                    ReD=5e5, altReD=nothing, Matip=0.0,\n\n                    # OUTPUT OPTIONS\n                    verbose=false, verbose_xfoil=false, v_lvl=1,\n                    plot_disc=true, save_polars=nothing)\n\nGenerates a FLOWVLM.Rotor from direct inputs.\n\nARGUMENTS\n\nRtip::Real      :   (m) rotor radius (from centerline to blade tip)\nRhub::Real      :   (m) hub radius (from centerline to blade root)\nB::Int          :   Number of blades\nchorddist::Matrix   : Chord distribution (chorddist[:, 1] = r/R, chorddist[:, 2] = c/R\ntwistdist::Matrix   : Twist distribution (twistdist[:, 1] = r/R, twistdist[:, 2] = degs\nsweepdist::Matrix   : LE sweep distribution (sweepdist[:, 1] = r/R, sweepdist[:, 2] = x/R\nheightdist::Matrix  : LE height distribution (heightdist[:, 1] = r/R, heightdist[:, 2] = z/R\nairfoil_contours::Array{ Tuple{Float64, Array{Float64, 2}, String} }    :                           Airfoil contours along the span. It must follow the                           pattern (pos, contour, polarfile) = airfoil_contours[i],                           where pos = (r-Rhub)/(Rtip-Rhub) is the spanwise                           position (with root=0, tip=1), contour is the                           airfoil profile (contour[:, 1] = x/c, contour[:, 2] = y/c),                           and polarfile is any file from                           airfoiltools.com with                           the airfoil lookup table (airfoil polar).\n\nThe function allows airfoil_contours::Array{ Tuple{Float64, String, String} }, following the pattern (pos, contourfile, polarfile) = airfoil_contours[i] where contourfile is a CSV file with columns x/c and y/c.\n\nKEYWORD ARGUMENTS\n\nExtra rotor parameters\n\npitch::Real         :   (deg) rotor collective pitch\nCW::Bool            :   Whether the rotor rotates in the clockwise (true)                           or counter-clockwise (false)\n\nDiscretization\n\nn::Int              :   Number of blade elements per blade.\nr::Real             :   Spacing between elements at the tip, divided by                           the spacing between elements at the root.\nspline_k::Int, spline_s::Real, spline_bc::String : To discretize the                           blade, the blade distributions are splined and                           re-discretize into n elements. These splines                           are done through the Dierckx package,                           with spline_k the order of the spline, spline_s                           the smoothing parameter, and spline_bc the                           boundary condition.\nrediscretize_airfoils   : If true, it will spline the airfoil contours and                               re-discretize them. It will discretize the lower                               side of the contour into rfl_n_lower panels,                               and the upper side into rfl_n_upper panels.                               This is necessary unless all the airfoil                               contours already have the same number of points.\n\nAirfoil processing\n\ndata_path::String   :   Path to database where to read the airfoil polars                           from.\nread_polar::Function :  Function used for parsing the airfoil files. Use                           vlm.ap.read_polar for files that are direct                           outputs from XFOIL. Use vlm.ap.read_polar2 for CSV                           files.\nxfoil::Bool         :   If true, the polar files will be ignored and XFOIL                           will be used to generate the polars instead. This                           will be done sweeping AOA as in alphas                           (in degrees) and ncrit for inflow turbulence                           parameter.\nReD::Real, Matip::Real, altReD::Tuple{Real, Real, Real}\n\nReD is the diameter Reynolds number based on rotational speed calculated as ReD = (omega*R)*(2*R)/nu, and Matip is the rotational+freestream Mach number at the tip. These number will be used for running XFOIL to compute airfoil polars, and will be ignored if airfoil polars are prescribed.\n\nGive it altReD = (RPM, J, nu), and it will calculate the chord-based Reynolds accounting for the effective velocity at every station, ignoring ReD (this is more accurate, but not needed).\n\nNOTE: If Matip is different than zero while running XFOIL, you must deactive compressibility corrections in run_simulation by using sound_spd=nothing. Otherwise, compressibility effects will be double accounted for.\n\nOutputs\n\nverbose::Bool       :   Whether to verbose while generating the rotor\nverbose_xfoil::Bool :   Whether to verbose while running XFOIL\nv_lvl::Int          :   Indentation level for printing the verbose\nplot_disc           :   If true, it will plot the discretization process                           of the blade, which is useful for verification and                           debugging. It will also plot the airfoil polars.\nsave_polars::String :   Give it a path to a directory and it will save the                           polars plot in that directory\n\n\n\n\n\n","category":"method"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.rotate","page":"Generating components","title":"FLOWVLM.rotate","text":"rotate(rotor::Rotor, degs::Real)\n\nRotates the rotor by degs degrees in the direction of rotation (rotor.CW).\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#VLM-Wing","page":"Generating components","title":"VLM Wing","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWUnsteady.vlm.simpleWing\nFLOWUnsteady.vlm.complexWing","category":"page"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.simpleWing","page":"Generating components","title":"FLOWVLM.simpleWing","text":"simpleWing(b, ar, tr, twist, lambda, gamma; twist_tip=twist, n=20, r=2.0)\n\nGenerates a simple wing with constant twist, sweep, dihedral, and taper ratio.\n\nArguments\n\nb       :   (float) span\nar      :   (float) aspect ratio (span / tip chord)\ntr      :   (float) taper ratio (tip chord / root chord)\ntwist   :   (float) twist of the root in degrees\nlambda  :   (float) sweep in degrees\ngamma   :   (float) dihedral in degrees\ntwist_tip : (float) twist of the tip (if different than root)\nn       :   (int)   number of horseshoes per semi-span\nr       :   (float) horseshoes' expansion ratio\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.complexWing","page":"Generating components","title":"FLOWVLM.complexWing","text":"complexWing(b, AR, tr, n, pos, twist, sweep, dihed; symmetric=true)\n\nGenerates a wing with an abritrary distribution of twist, sweep, dihedral, and chord length.\n\nArguments\n\nb::Float64          : Span\nAR::Float64         : Reference aspect ratio (span / tip chord)\nn::Int64            : Number of horseshoes per semi-span\npos::Array{Float64,1}   : Position of stations along the semi-span\nclen::Array{Float64,1}  : Chord length at each station (normalized by tip chord)\ntwist::Array{Float64,1} : (deg) twist at each station\nsweep::Array{Float64,1} : (deg) sweep between each station\ndihed::Array{Float64,1} : (deg) dihedral between each station\n\nOptional Arguments\n\nsymmetric::Bool=true    : If false, generates only a half-span\nchordalign::Float64=0.0 : Indicate position along chord length to align                             chords. Give it 0 for alignment about leading                             edge, 0.25 for alignment about quarter chord,                             and 1.0 for alignment about trailing edge.\n\nExample\n\n# Wing dimensions\nb = 1.0                     # (m) span\nAR = 12.0                   # Span over tip chord\nn = 50                      # Horseshoes per semi-span\n\n# Define chord, twist, sweep, and dihedral distributions\npos = [0, 0.25, 0.75, 1]    # Position of stations along semi-span\nclen = [2.0, 1.5, 1.5, 1]   # Normalized chord length at each station\ntwist = [0.0, 0.0, -2.0, -4.0]    # (deg) twist at each station\nsweep = [10.0, 15.0, 35.0]  # (deg) sweep between stations\ndihed = [2.0, 5.0, 7.5]     # (deg) dihedral between stations\n\n# Generate the wing\nwing = vlm.complexWing(b, AR, n, pos, clen, twist, sweep, dihed)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM-Systems","page":"Generating components","title":"FLOWVLM Systems","text":"","category":"section"},{"location":"api/flowunsteady-vehicle-components/","page":"Generating components","title":"Generating components","text":"FLOWUnsteady.vlm.WingSystem\n\nFLOWUnsteady.vlm.addwing\nFLOWUnsteady.vlm.get_wing\nFLOWUnsteady.vlm.setcoordsystem\nFLOWUnsteady.vlm.get_m\nFLOWUnsteady.vlm.get_mBlade","category":"page"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.WingSystem","page":"Generating components","title":"FLOWVLM.WingSystem","text":"WingSystem(wings::Array{Union{Wing, WingSystem}}, wing_names::Array{String})\n\nInitiates a system of wings. All methods applicable to a Wing object are applicable to a WingSystem. When solved, it will calculate the interaction between wings.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.addwing","page":"Generating components","title":"FLOWVLM.addwing","text":"addwing(self::WingSystem, wing_name::String, wing::Union{Wing, Rotor})\n\nAdds a wing (or rotor) to the system. The local reference frame of the wing then is then in relation to the local reference frame of the System.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.get_wing","page":"Generating components","title":"FLOWVLM.get_wing","text":"get_wing(self::WingSystem, wing_name::String)\n\nReturns the wing of name wing_name.\n\n\n\n\n\nget_wing(self::WingSystem, wing_i::Int)\n\nReturns the i-th wing.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.setcoordsystem","page":"Generating components","title":"FLOWVLM.setcoordsystem","text":"setcoordsystem(wing::Wing, O::Vector, Oaxis::Matrix)\n\nRedefines the local coordinate system of the wing, where O is the new origin and Oaxis is the matrix of unit vectors\n\n\n\n\n\nsetcoordsystem(system::WingSystem, O::Vector, Oaxis::Matrix; wings=String[])\n\nRedefines the local coordinate system of the system, where O is the new origin and Oaxis is the matrix of unit vectors. It transforms the coordinates of all wings in the system accordingly.\n\nTo change the local coordinate system of a specific wing relative to the system's coordinate system, give the name of the wing in an array under argument wings.\n\n\n\n\n\nsetcoordsystem(rotor::Rotor, O::Vector, Oaxis::Matrix; user=false)\n\nRedefines the local coordinate system of the rotor, where O is the new origin and Oaxis is the matrix of unit vectors. If the user is calling this function, give user=true, otherwise it will not do the automatic translation to blade coordinate system.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.get_m","page":"Generating components","title":"FLOWVLM.get_m","text":"get_m(wing::Wing)\n\nReturns the number of horseshoes in the wing\n\n\n\n\n\nget_m(system::WingSystem)\n\nReturns the total number of horseshoes in the system\n\n\n\n\n\nget_m(rotor::Rotor)\n\nReturns the total number of horseshoes in the rotor\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-vehicle-components/#FLOWVLM.get_mBlade","page":"Generating components","title":"FLOWVLM.get_mBlade","text":"get_mBlade(rotor::Rotor)\n\nReturns the number of horseshoes per blade\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-noise/#Aeroacoustic-Noise","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"","category":"section"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"FLOWUnsteady uses an FW-H code and a BPM code for calculating tonal and broadband aeroacoustic noise, respectively. The tonal code (PSU-WOPWOP) is not included in the FLOWUnsteady suite, but the user can request a binary of PSU-WOPWOP directly from the developers at Penn State University.","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"The example under examples/rotornoise/singlerotor.ipynb shows validation of the aeroacoustics solver and instructions on how to run a rotor noise analysis. Further validation of rotor-on-rotor interactions is given in the following paper by the authors:","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"Alvarez, E. J., Schenk, A., Critchfield, T., and Ning, A., “Rotor-on-Rotor Aeroacoustic Interactions of Multirotor in Hover,” The Vertical Flight Society’s 76th Annual Forum, 2020, Jul. 2020. [SLIDES][PDF]","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/dji9443_ccblade01_1.gif\" alt=\"Vid\" width=\"75%\"/>","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/cfdnoise_ningdji_multi_005D_03_20.gif\" alt=\"Vid\" width=\"75%\"/>","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"<div style=\"position:relative;padding-top:60%;\">\n  <iframe style=\"position:absolute;left:0;top:0;height:100%;width:100%;\" src=\"https://www.youtube.com/embed/ntQjP6KbZDk?hd=1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n</div>","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/","page":"Aeroacoustic Noise","title":"Aeroacoustic Noise","text":"FLOWUnsteady.run_noise_wopwop\nFLOWUnsteady.run_noise_bpm","category":"page"},{"location":"api/flowunsteady-postprocessing-noise/#FLOWUnsteady.run_noise_wopwop","page":"Aeroacoustic Noise","title":"FLOWUnsteady.run_noise_wopwop","text":"Given the path of a FLOWUnsteady simulation read_path, it runs the noise analysis on the rotors of the simulation. It uses PSU-WOPWOP to calculate the tonal noise from thickness and loading sources on the geometry and aerodynamic loading.\n\nrun_noise_wopwop(\n    read_path::String,              # Path from where to read aerodynamic solution (FLOWUnsteady simulation)\n    run_name,                       # Run name (prefix of rotor files to read)\n    RPM::Real,                      # Reference RPM to convert `nrevs` to simulation time\n    rho::Real, speedofsound::Real,  # Air density and speed of sound\n    rotorsystems,                   # `rotorsystems[i][j]` is the number of blades of the j-th rotor in the i-th system\n    ww_nrevs,                       # Run PSU-WOPWOP for this many revolutions\n    ww_nsteps_per_rev,              # Number of steps per revolution to use in WW\n    save_path::String,              # Where to save PSU-WOPWOP results\n    wopwopbin;                      # Path to PSU-WOPWOP binary\n    nrevs           = nothing,      # Number of revolutions to read (defaults to `ww_nrevs`)\n    nsteps_per_rev  = nothing,      # Number of steps per revolution to read (default to `ww_nsteps_per_rev`)\n\n    # ---------- OBSERVERS ---------------------------------------\n    Vobserver   = nothing,          # (m/s) velocity of observer (vector)\n    sph_R       = 1.5*6.5,          # (m) sphere radius\n    sph_nR      = 0,                # Number of cells in radial direction\n    sph_ntht = 24, sph_nphi = 24,   # Number of cells in polar and azimuthal directions\n    sph_thtmin = 5, sph_thtmax = 175,   # (deg) Bounds of polar direction\n    sph_phimax  = 180,              # (deg) maximum azimuthal angle (use 180 to make a hemisphere)\n    sph_rotation= [0, 90, 0],       # (degs) rotate the sphere by these angles\n    sph_C       = zeros(3),         # (m) center of sphere\n    microphoneX = nothing,          # If given, replaces sphere with one observer at this position\n    highpass = nothing, lowpass = nothing, # Low and high pass filters\n    windowing   = nothing,          # Windowing method\n    output_octaves = true,          # Whether to output octave bands\n    Noctave     = 3,                # Number of octave bands\n\n    # ---------- SIMULATION OPTIONS -----------------------------\n    periodic    = true,             # Whether rotor loading and translation in aerodynamic solution is periodic\n\n    # ---------- INPUT OPTIONS ----------------------------------\n    num_min     = 0,                # Start reading loading files from this number\n    const_geometry = false,         # Whether to run PSW on a constant geometry, obtained from num_min\n    axisrot     = \"automatic\",      # Axis of rotation to use for constant geometry (defaults to [1,0,0])\n    CW          = true,             # Clockwise or counter-clockwise rotation of constant geometry\n\n    # ---------- OUTPUT OPTIONS ---------------------------------\n    prompt      = true,             # Whether to prompt the user\n    verbose     = true,             # Whether to verbose\n    v_lvl       = 0,                # Indentation level when printing verbose\n    debug_paraview = false,         # Whether to visualize the grid of observers in Paraview before running\n    debuglvl    = 1,                # PSU-WOPWOP debug level\n    observerf_name = \"observergrid\",# .xyz file with observer grid\n    case_name   = \"runcase\",        # Name of case to create and run\n)\n\nNOTE: This function will call the PSU-WOPWOP binary indicated through wopwopbin. This binary is not included with FLOWUnsteady and must be provided by the user. This method has been tested on PSU-WOPWOP v3.4.2.\n\nNOTE 2: Make sure that the simulation was run with nsteps_save=1, otherwise the time in PSU-WOPWOP will get messed up.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-noise/#FLOWUnsteady.run_noise_bpm","page":"Aeroacoustic Noise","title":"FLOWUnsteady.run_noise_bpm","text":"Calculates broadband rotor noise through the Brooks, Pope, and Marcolini method using the BPM.jl package.\n\nThis writes the results to a file in the same format than PSU-WOPWOP, which can be read afterwards with FLOWNoise.readwopwopoutput(). It writes three files: SPL (non-weighted), A-weighted SPL, and OASPL.\n\nThis method assumes steady conditions and that all rotors have the same RPM.\n\nfunction run_noise_bpm(\n    rotors::Array{vlm.Rotor, 1},    # Rotors\n    RPM::Real,                      # RPM of rotors\n    Vinf::Function,                 # Freestream\n    rho::Real, mu::Real, speedofsound::Real, # Air density, dynamic viscosity, and speed of sound\n    save_path::String;              # Where to save results\n\n    # ---------- OBSERVERS --------------------------------------\n    sph_R       = 1.5*6.5,          # (m) sphere radius\n    sph_nR      = 0,                # Number of cells in radial direction\n    sph_ntht = 24, sph_nphi = 24,   # Number of cells in polar and azimuthal directions\n    sph_thtmin = 5, sph_thtmax = 175,   # (deg) Bounds of polar direction\n    sph_phimax  = 180,              # (deg) maximum azimuthal angle (use 180 to make a hemisphere)\n    sph_rotation= [0, 90, 0],       # (degs) rotate the sphere by these angles\n    sph_C       = zeros(3),         # (m) center of sphere\n    microphoneX = nothing,          # If given, replaces sphere with one observer at this position\n\n    # ---------- BPM OPTIONS ------------------------------------\n    noise_correction = 0.5,         # Broadband calibration correction\n    TE_thickness::Union{Float64, Array{Float64, 1}}=16.15,  # Trailing edge thickness (in degrees)\n    freq_bins   = BPM.default_f,    # Frequency bins\n    db_offset   = BPM.default_AdB,  # dB offset of every frequency for A-weighting\n\n    # ---------- OUTPUT OPTIONS ---------------------------------\n    prompt      = true,             # Whether to prompt the user\n    verbose     = true,             # Whether to verbose\n    v_lvl       = 0,                # Indentation level when printing verbose\n)\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-viscous/#Viscous-Scheme","page":"Viscous Scheme","title":"Viscous Scheme","text":"","category":"section"},{"location":"api/flowvpm-viscous/","page":"Viscous Scheme","title":"Viscous Scheme","text":"FLOWUnsteady.vpm.ViscousScheme\nFLOWUnsteady.vpm.Inviscid\nFLOWUnsteady.vpm.CoreSpreading\nFLOWUnsteady.vpm.ParticleStrengthExchange\nFLOWUnsteady.vpm.rbf_conjugategradient","category":"page"},{"location":"api/flowvpm-viscous/#FLOWVPM.ViscousScheme","page":"Viscous Scheme","title":"FLOWVPM.ViscousScheme","text":"`ViscousScheme{R}`\n\nType declaring viscous scheme.\n\nImplementations must have the following properties:     * nu::R                   : Kinematic viscosity.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-viscous/#FLOWVPM.rbf_conjugategradient","page":"Viscous Scheme","title":"FLOWVPM.rbf_conjugategradient","text":"Radial basis function interpolation of Gamma using the conjugate gradient method. This method only works on a particle field with uniform smoothing radius sigma.\n\nSee 20180818 notebook and https://en.wikipedia.org/wiki/Conjugategradientmethod#Theresultingalgorithm\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#SFS-Scheme","page":"SFS Scheme","title":"SFS Scheme","text":"","category":"section"},{"location":"api/flowvpm-sfs/","page":"SFS Scheme","title":"SFS Scheme","text":"FLOWUnsteady.vpm.SubFilterScale\nFLOWUnsteady.vpm.NoSFS\nFLOWUnsteady.vpm.ConstantSFS\nFLOWUnsteady.vpm.DynamicSFS\nFLOWUnsteady.vpm.clipping_backscatter\nFLOWUnsteady.vpm.control_directional\nFLOWUnsteady.vpm.control_magnitude\nFLOWUnsteady.vpm.dynamicprocedure_pseudo3level\nFLOWUnsteady.vpm.dynamicprocedure_sensorfunction\nFLOWUnsteady.vpm.Estr_direct\nFLOWUnsteady.vpm.Estr_fmm\nFLOWUnsteady.vpm.Estr_direct\nFLOWUnsteady.vpm.Estr_direct","category":"page"},{"location":"api/flowvpm-sfs/#FLOWVPM.SubFilterScale","page":"SFS Scheme","title":"FLOWVPM.SubFilterScale","text":"Implementation of calculations associated with subfilter-scale turbulence\n\nmodel.\n\nNOTE: Any implementation is expected to evaluate UJ and SFS terms of the particles which will be used by the time integration routine so make sure they are stored in the memory (see implementation of ConstantSFS as an example).\n\nNOTE2: Any control strategy is implemented as a function that returns true whenever the SFS model needs to be clipped. Subsequently, the model coefficient of the targeted particle will be turned to zero.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-sfs/#FLOWVPM.DynamicSFS","page":"SFS Scheme","title":"FLOWVPM.DynamicSFS","text":"Subfilter-scale scheme with an associated dynamic procedure for calculating\n\nthe model coefficient.\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-sfs/#FLOWVPM.clipping_backscatter","page":"SFS Scheme","title":"FLOWVPM.clipping_backscatter","text":"Backscatter control strategy of SFS enstrophy production by clipping of the\n\nSFS model. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.control_directional","page":"SFS Scheme","title":"FLOWVPM.control_directional","text":"Directional control strategy of SFS enstrophy production forcing the model\n\nto affect only the vortex strength magnitude and not the vortex orientation. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.control_magnitude","page":"SFS Scheme","title":"FLOWVPM.control_magnitude","text":"Magnitude control strategy of SFS enstrophy production limiting the\n\nmagnitude of the forward scattering (diffussion) of the model. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.dynamicprocedure_pseudo3level","page":"SFS Scheme","title":"FLOWVPM.dynamicprocedure_pseudo3level","text":"Dynamic procedure for SFS model coefficient based on enstrophy and\n\nderivative balance between resolved and unresolved domain, numerically implemented through pseudo-three filtering levels. See 20210901 notebook for derivation.\n\nNOTES\n\nrlxf = Δ𝑡/𝑇 ≤ 1 is the relaxation factor of the Lagrangian average, where Δ𝑡\n\nis the time step of the simulation, and 𝑇 is the time length of the ensemble average.\n\nThe scaling constant becomes 1 for alpha_tau = 1 (but notice that the\n\nderivative approximation becomes zero at that point). Hence, the pseudo-three-level procedure converges to the two-level procedure for alpha_tau rightarrow 1**.\n\nThe scaling constant tends to zero when alpha_tau rightarrow 23. Hence,\n\nit can be used to arbitrarely attenuate the SFS contributions with alpha_tau rightarrow 23, or let it trully be a self-regulated dynamic procedure with alpha_tau rightarrow 1.\n\nalpha_tau\nshould not be made smaller than 23 as the constant becomes\n\nnegative beyond that point. This strains the assumption that sigma_tau is small enough to approximate the singular velocity field as mathbfu approx mathbftildeu, which now is only true if sigma is small enough.\n\n𝛼𝜏=0.999 ⇒ 3𝛼𝜏−2=0.997 𝛼𝜏=0.990 ⇒ 3𝛼𝜏−2=0.970 𝛼𝜏=0.900 ⇒ 3𝛼𝜏−2=0.700 𝛼𝜏=0.833 ⇒ 3𝛼𝜏−2=0.499 𝛼𝜏=0.750 ⇒ 3𝛼𝜏−2=0.250 𝛼𝜏=0.700 ⇒ 3𝛼𝜏−2=0.100 𝛼𝜏=0.675 ⇒ 3𝛼𝜏−2=0.025 𝛼𝜏=0.670 ⇒ 3𝛼𝜏−2=0.010 𝛼𝜏=0.667 ⇒ 3𝛼𝜏−2=0.001 𝛼𝜏=0.6667⇒ 3𝛼𝜏−2=0.0001\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.dynamicprocedure_sensorfunction","page":"SFS Scheme","title":"FLOWVPM.dynamicprocedure_sensorfunction","text":"Dynamic procedure for SFS model coefficient based on sensor function of\n\nenstrophy between resolved and unresolved domain, numerically implemented through a test filter. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.Estr_direct","page":"SFS Scheme","title":"FLOWVPM.Estr_direct","text":"Model of vortex-stretching SFS contributions evaluated with direct\n\nparticle-to-particle interactions. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-sfs/#FLOWVPM.Estr_fmm","page":"SFS Scheme","title":"FLOWVPM.Estr_fmm","text":"Model of vortex-stretching SFS contributions evaluated with fast multipole\n\nmethod. See 20210901 notebook for derivation.\n\n\n\n\n\n","category":"function"},{"location":"theory/convergence/#Convergence","page":"Convergence","title":"Convergence","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"The following is a compilation of convergence studies found in the literature using FLOWUnsteady.","category":"page"},{"location":"theory/convergence/#Wing-Performance","page":"Convergence","title":"Wing Performance","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: E. J. Alvarez, 2022[1]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-particles06.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-n100-00.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: 45^circ swept-back wing at an angle of attack of 42^circ. Aspect ratio of 5.0, RAE 101 airfoil section with 12% thickness, no dihedral, twist, nor taper. Freestream velocity of 497mathrmms, corresponding to a chord-based Reynolds number of 17 times 10^6. Convergence of loading distribution and integrated lift and drag as the number of wing elements is increased.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways:Resolving the wake for about 1.5 span-distances is sufficient to converge wing loading\nUsing between 100 and 200 elements fully resolves the wing loading (C_D changes by less than 1% with n_mathrmwing  100)","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<table>\n  <tr>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-conv00.png\"\n                                                        alt=\"Pic here\" style=\"width: 65%;\"/>\n    </td>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-conv01.png\"\n                                                        alt=\"Pic here\" style=\"width: 80%;\"/>\n    </td>\n  </tr>\n</table>\n\n<br>\n\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-conv02.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/#Rotor-Performance","page":"Convergence","title":"Rotor Performance","text":"","category":"section"},{"location":"theory/convergence/#APC-10x7-Propeller-Case","page":"Convergence","title":"APC 10x7 Propeller Case","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: E. J. Alvarez and A. Ning, 2020[2]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/propmodel00.png\" alt=\"Pic here\" style=\"width: 55%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: APC 10x7E propeller at an advance ratio of 0.6, tip Mach number of 0.36, and mathrmRe_c = 62 times 10^4 and mathrmRe_D = 65 times 10^5. Convergence of thrust w.r.t. the following parameters:N_mathrmsteps, number of time steps per revolution.\nN_mathrmsheds, number of particle sheds per revolution.\nlambda, core overlap between tip particles defined as lambda=fracsigmaDelta x. Also controlled with the particle smoothing factor f_sigma = sigmaR, .\nn, number of blade elements per blade.Default values: N_mathrmsteps=72, N_mathrmsheds=144, lambda=2125 (or f_sigma=0093), and n=50 as each parameter is independently varied.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways:Temporal discretization error less than 1% with N_mathrmsteps geq 72 (or time step smaller  than 5^circ)\nSpatial discretization error less than 1% with N_mathrmsheds geq 144 and n = 50.\nC_T starts to diverge as the stability threshold (lambda=1) is approached, while also diverging as f_sigma025 (equivalent to sigma larger than 025R) leads to unphysical wake dynamics caused by excessive smoothing. Since the instability associated with lambdarightarrow1 plateaus at lambdaapprox2, we recommend using lambda approx 2125 whenever possible.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apcconv00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<table>\n  <tr>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apcconv01.png\"\n                                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    </td>\n    <td align=center>\n      <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apcconv02.png\"\n                                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    </td>\n  </tr>\n</table>\n\n<br>","category":"page"},{"location":"theory/convergence/#Beaver-Propeller-Case","page":"Convergence","title":"Beaver Propeller Case","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Beaver convergence.","category":"page"},{"location":"theory/convergence/#Wind-Turbine-Case","page":"Convergence","title":"Wind Turbine Case","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Source: J. Mehr, E. J. Alvarez, and A. Ning, 2022[4]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine.png\" alt=\"Pic here\" style=\"width: 45%;\"/>\n</center>","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Case: Test series \"H\" from UAE study at US Department of Energy.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Takeaways:Spatio-temporal discretization error on thrust C_T is less than 1% with 72 steps per revolution (or 5^circ per step), while error on power C_P is less than 3%.\nBlade discretization error less than 0.1% with 50 blade elements per blade.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine-conv00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine-conv01.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/convergence/#Rotor-Wake","page":"Convergence","title":"Rotor Wake","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"Beaver wake convergence.","category":"page"},{"location":"theory/convergence/#Immersed-Vorticity","page":"Convergence","title":"Immersed Vorticity","text":"","category":"section"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"1/100 sigma rule.","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[1]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [PDF]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[2]: E. J. Alvarez & A. Ning (2020), \"High-Fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design,\" AIAA Journal. [DOI] [PDF]","category":"page"},{"location":"theory/convergence/","page":"Convergence","title":"Convergence","text":"[4]: J. Mehr, E. J. Alvarez, & A. Ning (2022), \"Interactional Aerodynamics Analysis of a Multi-Rotor Energy Kite,\" (in review).","category":"page"},{"location":"api/flowunsteady-run/#(5)-Run-Simulation","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"","category":"section"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"FLOWUnsteady.run_simulation","category":"page"},{"location":"api/flowunsteady-run/#FLOWUnsteady.run_simulation","page":"(5) Run Simulation","title":"FLOWUnsteady.run_simulation","text":"Run the FLOWUnsteady simulation sim in nsteps number of time steps.\n\nrun_simulation(\n\n    sim::Simulation,                    # Simulation object\n    nsteps::Int;                        # Total time steps in simulation\n\n    # -------- SIMULATION OPTIONS -----------------------------------------\n    Vinf            = (X, t)->zeros(3), # Freestream velocity\n    sound_spd       = 343,              # (m/s) speed of sound\n    rho             = 1.225,            # (kg/m^3) air density\n    mu              = 1.81e-5,          # (Pa*s) air dynamic viscosity\n    tquit           = Inf,              # (s) force quit the simulation at this time\n    rand_RPM        = false,            # (experimental) randomize RPM fluctuations\n\n    extra_runtime_function = (sim, PFIELD, T, DT; optargs...)->false,\n\n    # -------- SOLVERS OPTIONS --------------------------------------------\n    # Vortex particle method\n    max_particles   = Int(1e5),         # Maximum number of particles\n    max_static_particles = nothing,     # Maximum number of static particles (use `nothing` to automatically estimate it)\n    p_per_step      = 1,                # Particle sheds per time step\n    vpm_formulation = vpm.rVPM,         # VPM formulation (`vpm.rVPM` or `vpm.cVPM`)\n    vpm_kernel      = vpm.gaussianerf,  # VPM kernel (`vpm.gaussianerf` or `vpm.winckelmans`)\n    vpm_UJ          = vpm.UJ_fmm,       # VPM particle-to-particle interaction scheme (`vpm.UJ_fmm` or `vpm.UJ_direct`)\n    vpm_SFS         = vpm.SFS_none,     # VPM LES subfilter-scale model (`SFS_none`, `SFS_Cd_threelevel_nobackscatter`, `SFS_Cd_twolevel_nobackscatter`, or `SFS_Cs_nobackscatter`)\n    vpm_integration = vpm.rungekutta3,  # VPM time integration scheme (`vpm.euler` or `vpm.rungekutta3`)\n    vpm_transposed  = true,             # VPM transposed stretching scheme\n    vpm_viscous     = vpm.Inviscid(),   # VPM viscous diffusion scheme (`vpm.Inviscid()`, `vpm.CoreSpreading(nu, sgm0, zeta)`, or `vpm.ParticleStrengthExchange(nu)`)\n    vpm_fmm         = vpm.FMM(; p=4, ncrit=50, theta=0.4, phi=0.5), # VPM's FMM settings\n    vpm_relaxation  = vpm.pedrizzetti,  # VPM relaxation scheme (`vpm.norelaxation`, `vpm.correctedpedrizzetti`, or `vpm.pedrizzetti`)\n    vpm_surface     = true,             # Whether to include surfaces in the VPM through ASM/ALM\n\n    # Actuator surface/line model (ASM/ALM): VLM and blade elements\n    vlm_vortexsheet = false,            # Whether to spread surface circulation as a vortex sheet in the VPM (turns ASM on; ALM if false)\n    vlm_vortexsheet_overlap     = 2.125,# Overlap of particles that make the vortex sheet\n    vlm_vortexsheet_distribution= g_pressure, # Vorticity distribution of vortex sheet (`g_uniform`, `g_linear`, or `g_pressure`)\n    vlm_vortexsheet_sigma_tbv   = nothing, # Size of particles in trailing bound vortices (defaults to `sigma_vlm_surf` if not given)\n    vlm_rlx         = -1,               # VLM relaxation (>0.9 can cause divergence, <0.2 slows simulation too much, deactivated with <0)\n    vlm_init        = false,            # Initialize the first step with the VLM semi-infinite wake solution\n    hubtiploss_correction = vlm.hubtiploss_nocorrection, # Hub and tip loss correction of rotors (ignored in quasi-steady solver)\n\n    # Wake shedding\n    wake_coupled        = true,         # Couple VPM wake -> VLM solution\n    shed_unsteady       = true,         # Whether to shed vorticity from unsteady loading\n    unsteady_shedcrit   = 0.01,         # Criterion for unsteady-loading shedding\n    shed_starting       = false,        # Whether to shed starting vortex (only when `shed_unsteady=true`)\n    shed_boundarylayer  = false,        # (experimental) whether to shed vorticity from boundary layer of surfaces\n    boundarylayer_prescribedCd = 0.1,   # (experimental) prescribed Cd for boundary layer shedding used for wings\n    boundarylayer_d     = 0.0,          # (experimental) dipole width for boundary layer shedding\n    omit_shedding       = [],           # Indices of elements in `sim.vehicle.wake_system` on which omit shedding VPM particles\n\n    # Regularization of solvers\n    sigma_vlm_solver    = -1,           # Regularization of VLM solver (internal VLM-on-VLM)\n    sigma_vlm_surf      = -1,           # (REQUIRED!) Size of embedded particles in ASM/ALM wing surfaces (for VLM-on-VPM and VLM-on-Rotor)\n    sigma_rotor_surf    = -1,           # (REQUIRED!) Size of embedded particles in ALM blade surfaces (for Rotor-on-VPM, Rotor-on-VLM, and Rotor-on-Rotor)\n    sigmafactor_vpm     = 1.0,          # Core overlap of wake particles\n    sigmafactor_vpmonvlm = 1,           # (experimental) shrinks the particles by this factor when calculating VPM-on-VLM/Rotor induced velocities\n    sigma_vpm_overwrite = nothing,      # Overwrite core size of wake to this value (ignoring `sigmafactor_vpm`)\n\n    # -------- RESTART OPTIONS --------------------------------------------\n    restart_vpmfile     = nothing,      # VPM restart file to restart simulation\n\n    # -------- OUTPUT OPTIONS ---------------------------------------------\n    save_path       = nothing,          # Where to save simulation\n    run_name        = \"flowunsteadysim\",# Suffix of output files\n    create_savepath = true,             # Whether to create `save_path`\n    prompt          = true,             # Whether to prompt the user\n    verbose         = true,             # Enable verbose\n    v_lvl           = 0,                # Indentation level of verbose\n    verbose_nsteps  = 10,               # Verbose every this many steps\n    raisewarnings   = true,             # Whether to raise warnings\n    debug           = false,            # Output extra states for debugging\n    nsteps_save     = 1,                # Save vtks every this many steps\n    nsteps_restart  = -1,               # Save jlds every this many steps (restart files)\n    save_code       = \"\",               # Copy the source code in this path to `save_path`\n    save_horseshoes = false,            # Whether to output VLM horseshoes in VTKs\n    save_static_particles = true,       # Whether to save ASM/ALM embedded particles\n    save_wopwopin   = false,            # Generate input files for PSU-WOPWOP\n\n)\n\nEven though a bast number of settings are exposed to the user, the only required keyword arguments are sigma_vlm_surf and sigma_rotor_surf. Thus, running the simulation can be as simple as\n\nrun_simulation(sim::Simulation, nsteps::Int;\n                    sigma_vlm_surf = ..., sigma_rotor_surf = ...)\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"compat: Extra Runtime Function\nextra_runtime_function is a function that is called at every time step after the state variables are updated and before outputting VTK files. The state variables of the simulation are passed to this function, giving the user complete freedom to modify the states of the simulation (e.g., add/remove particles, clip vortex strengths, re-orient the vehicle) or to do some extra computation (e.g., compute aerodynamic forces, create plots, write to files, etc).This function is expected be of the formextra_runtime_function(sim, pfield, t, dt; vprintln) -> Boolwhere sim is the FLOWUnsteady.Simulation object, pfield is the FLOWVPM.ParticleField, t is the current simulation time, dt is the length of the current time step, and vprintln(str, v_lvl) is a function for printing the verbose of the simulation (default to vprintln = (args...)->nothing if there is nothing to add to the verbose).The output of extra_runtime_function is a flag for breaking the simulation at the current time step, such that if it ever returns true, the simulation will immediately quit.","category":"page"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"compat: So, what is going on under the hood?\nFLOWUnsteady is simply a runtime function that is provided to FLOWVPM, as shown below. Hence, FLOWVPM (green block) is the solver that is actually driving the simulation. FLOWUnsteady (blue block) acts as a runtime function inside a VPM simulation that at each time step uses the solvers in the gray block to compute surface vorticities and adds particles to embed such vorticity in the flow field (thus implementing the actuator surface/line models developed in Alvarez' dissertation, Chapter 6).This workflow makes it very easy to couple more solvers in the simulation. For instance, a structural solver can be inserted as a runtime function (step 6 of the blue block) that deflects the geometry according to the aerodynamic loads, obtaining a full aeroelastic simulation.","category":"page"},{"location":"api/flowunsteady-run/","page":"(5) Run Simulation","title":"(5) Run Simulation","text":"<center>\n  <img src=\"../../assets/images/flowchart/flowchart00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-incidence/#Incidence-Sweep","page":"Incidence Sweep","title":"Incidence Sweep","text":"","category":"section"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//prowim_isoprop_J100-AOA200-00_3.gif\" alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"In simple cases like a propeller in cruise, steady and quasi-steady methods like blade element momentum theory can be as accurate as a fully unsteady simulation, and even faster. However, in more complex cases, quasi-steady solvers are far from accurate and a fully unsteady solver is needed. We now highlight one of such cases: the case of a propeller at an incidence angle.","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"A rotor operating at an incidence angle relative to the freestream experiences an unsteady loading due to the blade seeing a larger local velocity in the advancing side of the rotor and a smaller local velocity in the retreating side. This also causes a wake that is skewed. For this example we will run a sweep of simulations on a 4-bladed propeller operating at multiple incidence angles alpha (where alpha=0^circ is fully axial inflow, and alpha=90^circ is fully edgewise inflow).","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    Simulation of Beaver propeller (four-bladed rotor, 9.34-inch diameter) at\n    various incidence angles.\n\n    This example uses the blade geometry reported in Sinnige & de Vries (2018),\n    \"Unsteady Pylon Loading Caused by Propeller-Slipstream Impingement for\n    Tip-Mounted Propellers,\" and replicates the experiment conducted by Sinnige\n    et al. (2019), \"Wingtip-Mounted Propellers: Aerodynamic Analysis of\n    Interaction Effects and Comparison with Conventional Layout.\"\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\ncase_name       = \"propeller-incidencesweep-example\"    # Name of this sweep case\n\nsave_path       = case_name                 # Where to save this sweep\noutput_runs     = [20]                      # Saves the VTK output of these AOAs for viz\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n\n# Rotor geometry\nrotor_file      = \"beaver.csv\"              # Rotor geometry\ndata_path       = uns.def_data_path         # Path to rotor database\npitch           = 0.0                       # (deg) collective pitch of blades\nCW              = false                     # Clock-wise rotation\nxfoil           = false                     # Whether to run XFOIL\nread_polar      = vlm.ap.read_polar2        # What polar reader to use\n\n# Discretization\nn               = 20                        # Number of blade elements per blade\nr               = 1/5                       # Geometric expansion of elements\n\n# Read radius of this rotor and number of blades\nR, B            = uns.read_rotor(rotor_file; data_path=data_path)[[1,3]]\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n\n# Operating conditions\nAOAs            = 0:4:20                    # (deg) incidence angles to evaluate\nmagVinf         = 40.0                      # (m/s) freestream velocity\nJ               = 0.9                       # Advance ratio Vinf/(nD)\nRPM             = magVinf / (2*R/60) / J    # RPM\n\nrho             = 1.225                     # (kg/m^3) air density\nmu              = 1.79e-5                   # (kg/ms) air dynamic viscosity\nspeedofsound    = 342.35                    # (m/s) speed of sound\n\n\nReD             = 2*pi*RPM/60*R * rho/mu * 2*R      # Diameter-based Reynolds number\nMatip           = 2*pi*RPM/60*R / speedofsound      # Tip Mach number\n\nprintln(\"\"\"\n    RPM:    $(RPM)\n    Vinf:   $(magVinf) m/s\n    Matip:  $(round(Matip, digits=3))\n    ReD:    $(round(ReD, digits=0))\n\"\"\")\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n\n# Aerodynamic solver\nVehicleType     = uns.UVLMVehicle           # Unsteady solver\n\n# Time parameters\nnrevs           = 4                         # Number of revolutions in simulation\nnsteps_per_rev  = 36                        # Time steps per revolution\nnsteps          = nrevs*nsteps_per_rev      # Number of time steps\nttot            = nsteps/nsteps_per_rev / (RPM/60)       # (s) total simulation time\n\n# VPM particle shedding\np_per_step      = 2                         # Sheds per time step\nshed_starting   = true                      # Whether to shed starting vortex\nshed_unsteady   = true                      # Whether to shed vorticity from unsteady loading\nmax_particles   = ((2*n+1)*B)*nsteps*p_per_step + 1 # Maximum number of particles\n\n# Regularization\nsigma_rotor_surf= R/40                      # Rotor-on-VPM smoothing radius\n# sigma_rotor_surf= R/80\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * 2*pi*R/(nsteps_per_rev*p_per_step)\n\n# Rotor solver\nvlm_rlx         = 0.7                       # VLM relaxation <-- this also applied to rotors\n                                            # Prandtl's tip correction with a strong hub\nhubtiploss_correction = ( (0.75, 10, 0.5, 0.05), (1, 1, 1, 1.0) ) # correction up to r/R = 0.35\n\nif VehicleType == uns.QVLMVehicle           # Mute colinear warnings if quasi-steady solver\n    uns.vlm.VLMSolver._mute_warning(true)\nend\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate rotor\nrotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                        n=n, CW=CW, blade_r=r,\n                                        altReD=[RPM, J, mu/rho],\n                                        xfoil=xfoil,\n                                        read_polar=read_polar,\n                                        data_path=data_path,\n                                        verbose=true,\n                                        verbose_xfoil=false,\n                                        plot_disc=true\n                                        );\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Rotor\", rotor)\n\nrotors = [rotor];                           # Defining this rotor as its own system\nrotor_systems = (rotors, );                 # All systems of rotors\n\nwake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                            # NOTE: Do NOT include rotor when using the quasi-steady solver\nif VehicleType != uns.QVLMVehicle\n    vlm.addwing(wake_system, \"Rotor\", rotor)\nend\n\nvehicle = VehicleType(   system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                         );\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = zeros(3)\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# RPM control input over time (RPM over `RPMref`)\nRPMcontrol(t) = 1.0\n\nangles = ()                                 # Angle of each tilting system (none)\nRPMs = (RPMcontrol, )                       # RPM of each rotor system\n\nmaneuver = uns.KinematicManeuver(angles, RPMs, Vvehicle, anglevehicle)\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = 0.0                                  # Reference velocity to scale maneuver by\nRPMref = RPM                                # Reference RPM to scale maneuver by\n\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n# ------------- RUN AOA SWEEP --------------------------------------------------\n\n# Create path where to save sweep\nuns.gt.create_path(save_path, true)\n\nfor AOA in AOAs\n\n    println(\"\\n\\nRunning AOA = $(AOA)\")\n\n    Vinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector\n\n    # ------------- 4) MONITOR DEFINITION ---------\n    monitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                                t_scale=RPM/60,\n                                                t_lbl=\"Revolutions\",\n                                                save_path=save_path,\n                                                run_name=\"AOA$(ceil(Int, AOA*100))\",\n                                                disp_conv=false\n                                                )\n\n    # ------------- 5) RUN SIMULATION -------------\n    println(\"\\tRunning simulation...\")\n\n    save_vtks = AOA in output_runs ? save_path*\"-AOA$(ceil(Int, AOA*100))\" : nothing\n\n    uns.run_simulation(simulation, nsteps;\n                        # ----- SIMULATION OPTIONS -------------\n                        Vinf=Vinf,\n                        rho=rho, mu=mu, sound_spd=speedofsound,\n                        # ----- SOLVERS OPTIONS ----------------\n                        p_per_step=p_per_step,\n                        max_particles=max_particles,\n                        sigma_vlm_surf=sigma_rotor_surf,\n                        sigma_rotor_surf=sigma_rotor_surf,\n                        sigma_vpm_overwrite=sigma_vpm_overwrite,\n                        vlm_rlx=vlm_rlx,\n                        hubtiploss_correction=hubtiploss_correction,\n                        shed_unsteady=shed_unsteady,\n                        shed_starting=shed_starting,\n                        extra_runtime_function=monitor_rotor,\n                        # ----- OUTPUT OPTIONS ------------------\n                        save_path=save_vtks,\n                        run_name=\"singlerotor\",\n                        v_lvl=1, verbose_nsteps=24\n                        );\nend\n","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~15 minutes on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"Check examples/propeller/propeller_incidence.jl to postprocess and plot the results as shown below.","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-incidencesweep-example.png\" alt=\"Pic here\" style=\"width: 50%;\"/>\n</center>","category":"page"},{"location":"examples/propeller-incidence/","page":"Incidence Sweep","title":"Incidence Sweep","text":"info: Paraview visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...). To open in Paraview: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"api/flowvpm-particle/#Particle-Field","page":"Particle Field","title":"Particle Field","text":"","category":"section"},{"location":"api/flowvpm-particle/","page":"Particle Field","title":"Particle Field","text":"FLOWUnsteady.vpm.Particle\nFLOWUnsteady.vpm.ParticleField\nFLOWUnsteady.vpm.ClassicVPM\nFLOWUnsteady.vpm.ReformulatedVPM\nFLOWUnsteady.vpm.add_particle\nFLOWUnsteady.vpm.get_particle\nFLOWUnsteady.vpm.remove_particle\nFLOWUnsteady.vpm.get_np\nFLOWUnsteady.vpm.iterate\nFLOWUnsteady.vpm.get_particleiterator","category":"page"},{"location":"api/flowvpm-particle/#FLOWVPM.Particle","page":"Particle Field","title":"FLOWVPM.Particle","text":"`Particle{T}`\n\nVortex particle data structure\n\nState variables\n\nX::Array{T, 1}                : Position (3-elem array)\nGamma::Array{T, 1}            : Vectorial circulation (3-elem array)\nsigma::Array{T, 1}            : Smoothing radius (1-elem array)\nvol::Array{T, 1}              : Volume (1-elem array)\ncirculation::Array{T, 1}      : Scalar circulation (1-elem array)\n\nPublic calculations\n\nU::Array{T, 1}                : Velocity at particle (3-elem array)\nJ::Array{T, 2}                : Jacobian at particle J[i,j]=dUi/dxj (9-elem array)\n\n\n\n\n\n","category":"type"},{"location":"api/flowvpm-particle/#FLOWVPM.add_particle","page":"Particle Field","title":"FLOWVPM.add_particle","text":"add_particle(self::ParticleField, X, Gamma, sigma; vol=0, index=np)\n\nAdd a particle to the field.\n\n\n\n\n\nadd_particle(self::ParticleField, P::Particle)\n\nAdd a copy of Particle P to the field.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.get_particle","page":"Particle Field","title":"FLOWVPM.get_particle","text":"`get_particle(pfield::ParticleField, i)`\n\nReturns the i-th particle in the field.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.remove_particle","page":"Particle Field","title":"FLOWVPM.remove_particle","text":"remove_particle(pfield::ParticleField, i)\n\nRemove the i-th particle in the field. This is done by moving the last particle that entered the field into the memory slot of the target particle. To remove particles sequentally, you will need to go from the last particle back to the first one (see documentation of get_particleiterator for an example).\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.get_np","page":"Particle Field","title":"FLOWVPM.get_np","text":"`get_np(pfield::ParticleField)`\n\nReturns current number of particles in the field.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.iterate","page":"Particle Field","title":"FLOWVPM.iterate","text":"Alias for get_particleiterator\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-particle/#FLOWVPM.get_particleiterator","page":"Particle Field","title":"FLOWVPM.get_particleiterator","text":"`get_particleiterator(pfield::ParticleField; start_i=1, end_i=np)`\n\nReturn an iterator over particles that can be used as follows\n\njulia> # Initiate particle field\n       pfield = FLOWVPM.ParticleField(10);\n\njulia> # Add particles\n       for i in 1:4\n           FLOWVPM.add_particle(pfield, (i*10^0, i*10^1, i*10^2), zeros(3), 1.0)\n       end\n\njulia> # Iterate over particles\n       for P in FLOWVPM.get_particleiterator(pfield)\n           println(P.X)\n       end\n[1.0, 10.0, 100.0]\n[2.0, 20.0, 200.0]\n[3.0, 30.0, 300.0]\n[4.0, 40.0, 400.0]\n\n\n\n\n\n","category":"function"},{"location":"theory/validation/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"The following is a compilation of validation studies found in the literature using FLOWUnsteady.","category":"page"},{"location":"theory/validation/#Wing","page":"Validation","title":"Wing","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Sources: E. J. Alvarez, 2022,[1] and E. J. Alvarez and A. Ning, 2022[2]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-particles06.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-n100-00.png\" alt=\"Pic here\" style=\"width: 40%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: 45^circ swept-back wing at an angle of attack of 42^circ, aspect ratio of 5.0, RAE 101 airfoil section with 12% thickness, no dihedral, twist, nor taper. Freestream velocity of 497mathrmms, corresponding to a chord-based Reynolds number of 17 times 10^6. The high sweep of the wing causes non-negligible spanwise flow. The wing loads reported by Weber and Brebner (experimental) were integrated from pressure-tap measurements, hence the drag reported in this section includes induced and form drag while excluding skin friction drag.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from E. J. Alvarez and A. Ning, 2022[2]) \"Fig. 9 shows the loading distribution and integrated lift and drag across AOA predicted with the actuator surface model (ASM), compared to the experimental measurements. The loading distribution shows satisfactory agreement with the experiment, validating that both the circulation solver and the force calculation... are accurate for predicting not only lift but also drag distribution across the span. The integrated lift and drag (Fig. 9, bottom) show excellent agreement with the experiment from 0^circ to 105^circ. We expect this to be the case only for mild AOAs before approaching stall conditions since our ASM does not capture the mechanisms of flow separation. Thus, through this swept-wing case, we gain confidence that our ASM yields accurate predictions in conditions with spanwise flow up to a moderate AOA.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//weber-val00.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/validation/#Rotor","page":"Validation","title":"Rotor","text":"","category":"section"},{"location":"theory/validation/#Hover-Case","page":"Validation","title":"Hover Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"DJI aero from rVPM paper. DJI acoustics from VFS paper.","category":"page"},{"location":"theory/validation/#Forward-Flight-Case","page":"Validation","title":"Forward Flight Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Rachael's AVIATION paper.","category":"page"},{"location":"theory/validation/#Wind-Turbine","page":"Validation","title":"Wind Turbine","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: J. Mehr, E. J. Alvarez, and A. Ning, 2022[5]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine.png\" alt=\"Pic here\" style=\"width: 45%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: Test series \"H\" from UAE study at US Department of Energy. Sweep on tip speed ratio lambda = fracomega Ru_infty.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from E. J. Alvarez and A. Ning, 2020[3]) \"The torque coefficient outputs are also within 10% for tip speed ratios above, and within 25% for tip speed ratios under, lambda = 20; also notice that the absolute magnitudes of the torque coefficient are very small at low tip speed ratios, assuaging any concerns about the higher relative errors at those operational states.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/UAEturbine-val00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Propeller","page":"Validation","title":"Propeller","text":"","category":"section"},{"location":"theory/validation/#APC-10x7-Case","page":"Validation","title":"APC 10x7 Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Source: E. J. Alvarez and A. Ning, 2020[3]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apc10x7geom.png\" alt=\"Pic here\" style=\"width: 55%;\"/>\n</center>","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Case: APC 10x7E propeller (2 blades, 10'' diameter, solidity 0.1) at a tip Mach number of 0.36, mathrmRe_c = 62 times 10^4, and mathrmRe_D = 65 times 10^5. Sweep on advance ratio J = fracu_inftyn d.","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Results: (Excerpt from E. J. Alvarez and A. Ning, 2020[3]) \"... it is confirmed that the VPM propeller model is valid... across low and moderately high advance ratios.\"","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"\n<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/apc10x7val00.png\"\n      alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n\n<br>","category":"page"},{"location":"theory/validation/#Beaver-Case","page":"Validation","title":"Beaver Case","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"Beaver J sweep. Beaver incidence angle sweep. Propeller wake.","category":"page"},{"location":"theory/validation/#Rotor-Rotor-Interactions","page":"Validation","title":"Rotor-Rotor Interactions","text":"","category":"section"},{"location":"theory/validation/#Rotor-Wing-Interactions","page":"Validation","title":"Rotor-Wing Interactions","text":"","category":"section"},{"location":"theory/validation/#Horizontal-Stabilizer-w/-Tip-Mounted-Propellers","page":"Validation","title":"Horizontal-Stabilizer w/ Tip-Mounted Propellers","text":"","category":"section"},{"location":"theory/validation/#Blown-Wing","page":"Validation","title":"Blown Wing","text":"","category":"section"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[1]: E. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft,\" Doctoral Dissertation, Brigham Young University. [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[2]: E. J. Alvarez & A. Ning (2022), \"Meshless Large Eddy Simulation of Rotor-Wing Interactions Through the Reformulated Vortex Particle Method,\" (in review).","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[3]: E. J. Alvarez & A. Ning (2020), \"High-Fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design,\" AIAA Journal. [DOI] [PDF]","category":"page"},{"location":"theory/validation/","page":"Validation","title":"Validation","text":"[5]: J. Mehr, E. J. Alvarez, & A. Ning (2022), \"Interactional Aerodynamics Analysis of a Multi-Rotor Energy Kite,\" (in review).","category":"page"},{"location":"api/flowunsteady-postprocessing-fdom/#fluid_domain","page":"Fluid Domain","title":"Fluid Domain","text":"","category":"section"},{"location":"api/flowunsteady-postprocessing-fdom/","page":"Fluid Domain","title":"Fluid Domain","text":"  FLOWUnsteady.computefluiddomain\n  FLOWUnsteady.generate_preprocessing_fluiddomain_pfield","category":"page"},{"location":"api/flowunsteady-postprocessing-fdom/#FLOWUnsteady.computefluiddomain","page":"Fluid Domain","title":"FLOWUnsteady.computefluiddomain","text":"computefluiddomain( pfield::FLOWVPM.ParticleField,\n                    grids::Array{<:GeometricTools.AbstractGrid};\n                    optargs...\n                    )\n\nEvaluate the velocity and vorticity field induced by the particle field pfield at all nodes in a set of grids grids. The fields are added as solution fields U and W in each grid. The analytic Jacobian of the velocity field can also be saved using the optional argument add_J=true.\n\nOPTIONAL ARGUMENTS\n\nProcessing options\n\nadd_J::Bool=false       : Add the solution fields J1, J2, and J3 to                               each grid, where Ji[j]=dUi/dxj.\nadd_Uinf::Bool=false    : It evaluates and adds the uniform freestream to                               the U field.\nadd_Wapprox::Bool=false : It evaluates and saves the RBF-approximated                               vorticity field under the field Wapprox.\nzeta::Function=FLOWVPM.zeta_fmm : Method for evaluating RBF-approximated vorticity                               (used only if add_Wapprox==true).\nscale_sigma::Real=1.0   : It rescales the smoothing radius of each particle                               by this factor before evaluating the particle                               field.\n\nOutput options\n\nsave_path::String       : If used, it will save the grids as XDMF files                               under this path.\nfile_pref::String       : Prefix for XDMF files.\ngrid_names::String      : Name of each grid for XDMF files. If not given, it                               will generate their names automatically.\nnum::Int                : If given, the name of the XDMF files will be                               \"$(file_pref)$(grid_names[i]).$(num).vtk\"\nverbose::Bool=true      : Activate/deactivate verbose.\nv_lvl::Int=0            : Indentation level for printing verbose.\n\nNOTE: The solution fields U, W, and Jacobian do not include the freestream         field, but rather they only include the fields induced by the particles.         To add the freestream to U, use the optional argument add_Uinf=true.\n\n\n\n\n\ncomputefluiddomain(pfield::vpm.ParticleField,\n                    nums::Vector{Int}, read_path::String, file_pref::String,\n                    grids;\n                    origin=nothing,\n                    orientation=nothing,\n                    other_read_paths=[],\n                    other_file_prefs=[],\n                    userfunction_pfield=(pfield, num, grids)->nothing,\n                    optargs...\n                    )\n\nEvaluate the fluid domain at each time step in nums that is induced by a particle field saved under read_path. file_pref indicates the prefix of the .h5 files to read.\n\nTo translate and re-orient the grids at each time step, the user can pass the new origin vector and orientation matrix through the functions origin and orientation, which will be called as origin(pfield, num) and orientation(pfield, num) at each time step.\n\npfield is a place holder for loading the particles that are read, so the user must make sure that sufficient memory has been preallocated to hold the number of particles of each time step that will be read, plus the number of nodes in the grids. The fluid domain will be evaluated using the UJ and FMM configuration of the given pfield particle field.\n\nTo read and add more than one particle field at each time step, pass a list of paths and prefixes through other_read_paths and other_file_prefs. This is useful for reading and incluiding a set of static particles, for example.\n\nGive it a function userfunction_pfield to pre-process the resulting particle field before evaluating the fluid domain (e.g., remove particles, resize core sizes, etc).\n\n\n\n\n\ncomputefluiddomain(maxparticles::Int, args...;\n                    UJ::Function=vpm.UJ_fmm,\n                    fmm::FLOWVPM.FMM=vpm.FMM(; p=4, ncrit=50, theta=0.4, phi=0.5),\n                    pfield_optargs=[]\n                    optargs...)\n\nLike the other computefluiddomain(args...; optargs...) methods, but automatically pre-allocating and initializing the particle field with the given maximum number of particles, UJ evaluation method, and FMM configuration (if FMM is used by UJ).\n\nUse pfield_optargs to pass any additional optional arguments to the particle field constructor.\n\n\n\n\n\ncomputefluiddomain(P_min, P_max, NDIVS, args...;\n                    spacetransform=nothing,\n                    O=zeros(3), Oaxis=Float64[i==j for i in 1:3, j in 1:3],\n                    optargs...)`\n\nLike the other computefluiddomain(args...; optargs...) methods, but automatically generating a fluid domain grid. The grid is generated as a Cartesian box with minimum and maximum corners P_min and P_max and NDIVS cells.\n\nFor instance, P_min=[-1, -1, -1], P_max=[-1, -1, -1], and NDIVS=[10, 10, 50] will grid the volumetric space between -1 and 1 in all directions, with 10 cells in both the x and y-direction, and 50 cells in the z-direction.\n\nEven though the grid is first generated as a Cartesian grid, this can be transformed into any other structured space through the argument spacetransform, which is a function that takes any vector and returns another vector of the same dimensions. For instance, P_min=[0.5, 0, 0], P_max=[1, 2*pi, 5], NDIVS=[10, 20, 30], spacetransform=GeometricTools.cylindrical3D will generate a cylindrical grid discretizing the radial annulus from 0.5 to 1 with 10 cells, the polar angle from 0 to 360deg with 20 cells, and the axial z-distance from 0 through 5 with 30 cells.\n\nAny number of dimensions can be used, but make sure that P_min, P_max, and NDIVS always have three dimensions and indicate the dimensions that are \"collapsed\" with a 0 in NDIVS. Even though the grid is defined in the Cartesian axes, the origin and orientation of the grid can be specified with the O and Oaxis optional arguments. For instance, P_min=[0, 0, 1], P_max=[2, 3.5, 1], NDIVS=[10, 10, 0] will generate a 2D surface laying in the xy-plane at z=1.0, spanning from (x,y)=(0,0) to (x,y)=(2,3.5). Use O=[0, 0, -1] to move the surface back to the xy-plane at z=0. Use Oaxis=[1 0 0; 0 0 -1; 0 1 0] to re-orient the surface to lay in the zx-plane. The same thing can be achieved with Oaxis=GeometricTools.rotation_matrix2(-90, 0, 0) which generates the rotation matrix corresponding to a -90deg rotation about the x-axis.\n\nNOTE: The order of operation is (1) Cartesian grid generation, (2) space transformation if any, and (3) translation and re-orientation to the given origin and orientation.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-fdom/#FLOWUnsteady.generate_preprocessing_fluiddomain_pfield","page":"Fluid Domain","title":"FLOWUnsteady.generate_preprocessing_fluiddomain_pfield","text":"generate_preprocessing_fluiddomain_pfield(maxsigma, maxmagGamma;\n                                                verbose=true, v_lvl=1)\n\nGenerate function for pre-processing particle fields before generating fluid domain: shrink oversized particles and correct blown-up particles.\n\nPass the output function to FLOWUnsteady.computefluiddomain through the keyword argument userfunction_pfield. For example:\n\npreprocess_pfield = generate_preprocessing_fluiddomain_pfield(maxsigma, maxmagGamma;\n                                                                verbose=true, v_lvl=1)\n\ncomputefluiddomain( ... ; userfunction_pfield=preprocess_pfield, ...)\n\n\n\n\n\n","category":"function"},{"location":"examples/heavingwing/#Heaving-Wing","page":"Heaving Wing","title":"Heaving Wing","text":"","category":"section"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:74%;\"\n        src=\"https://www.youtube.com/embed/Pch94bKpjrQ?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"In this example we extend the simple wing case to create a case of interactional aerodynamics. We will place a straight wing flying in front of the original swept-back wing. The front wing will be moving in a heaving motion, shedding a wake that impinges on the back wing causing an unsteady loading.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"This simulation exemplify the following features:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"Defining a uns.VLMVehicle with multiple surfaces, one of them declared as a tilting surface\nDefining the control inputs for a tilting system in uns.KinematicManeuver (in this case, tilting the surface over time in a heaving motion)","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"#=##############################################################################\n# DESCRIPTION\n    Swept-back wing flying in the wake of a tandem wing in heaving motion.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Mar 2023\n  * Last updated    : Mar 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\nrun_name        = \"heavingwing-example\"    # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n# Back wing description\nb_back          = 2.489                     # (m) span length\nar_back         = 5.0                       # Aspect ratio b/c_tip\ntr_back         = 1.0                       # Taper ratio c_tip/c_root\ntwist_root_back = 0.0                       # (deg) twist at root\ntwist_tip_back  = 0.0                       # (deg) twist at tip\nlambda_back     = 45.0                      # (deg) sweep\ngamma_back      = 0.0                       # (deg) dihedral\n\n# Front wing description\nb_front         = 0.75*b_back\nar_front        = 5.0\ntr_front        = 1.0\ntwist_root_front= 5.0\ntwist_tip_front = 0.0\nlambda_front    = 0.0\ngamma_front     = 0.0\n\ndx              = 0.75*b_back               # (m) spacing between back and front wings\n\n# Discretization\nn_back          = 50                        # Number of spanwise elements per side\nr_back          = 2.0                       # Geometric expansion of elements\ncentral_back    = false                     # Whether expansion is central\n\nn_front         = 40\nr_front         = 10.0\ncentral_front   = false\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Vehicle motion\nmagVvehicle     = 49.7                      # (m/s) vehicle velocity\nAOA             = 4.2                       # (deg) angle of attack of back wing\nfrequency       = 25.0                      # (Hz) oscillation frequency in heaving motion\namplitude       = 5.0                       # (deg) AOA amplitude in heaving motion\n\n# Freestream\nmagVinf         = 1e-8                      # (m/s) freestream velocity\nrho             = 0.93                      # (kg/m^3) air density\nqinf            = 0.5*rho*magVvehicle^2     # (Pa) static pressure (reference)\n\nVinf(X, t)      = t==0 ? magVvehicle*[1,0,0] : magVinf*[1,0,0] # Freestream function\n\n# NOTE: In this simulation we will have the vehicle (the two wings) move while\n#       the freestream is zero. However, a zero freestream can cause some\n#       numerical instabilities in the solvers. To avoid instabilities, it is\n#       recommended giving a full freestream velocity (or the velocity of the\n#       vehicle) in the first time step `t=0`, and a negligible small velocity\n#       at any other time, as shown above in the definition of `Vinf(X ,t)`.\n\nmagVref         = magVvehicle               # (m/s) reference velocity (for calculation\n                                            # purposes since freestream is zero)\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Time parameters\nwakelength      = 4.0*b_back                # (m) length of wake to be resolved\nttot            = wakelength/magVref        # (s) total simulation time\nnsteps          = 200                       # Number of time steps\n\n# VLM and VPM parameters\np_per_step      = 2                         # Number of particle sheds per time step\n\nsigma_vlm_solver= -1                        # VLM-on-VLM smoothing radius (deactivated with <0)\nsigma_vlm_surf  = 0.05*b_back               # VLM-on-VPM smoothing radius\nlambda_vpm      = 2.0                       # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * magVref * (ttot/nsteps)/p_per_step\n\nshed_starting   = true                      # Whether to shed starting vortex\nvlm_rlx         = 0.7                       # VLM relaxation\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate back wing\nbackwing = vlm.simpleWing(b_back, ar_back, tr_back, twist_root_back,\n                            lambda_back, gamma_back; twist_tip=twist_tip_back,\n                            n=n_back, r=r_back, central=central_back);\n\n# Pitch back wing to its angle of attack\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0.0, -AOA, 0.0)     # New orientation\nvlm.setcoordsystem(backwing, O, Oaxis)\n\n# Generate front wing\nfrontwing = vlm.simpleWing(b_front, ar_front, tr_front, twist_root_front,\n                            lambda_front, gamma_front; twist_tip=twist_tip_front,\n                            n=n_front, r=r_front, central=central_front);\n\n# Move wing to the front\nO = [-dx, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0.0, 0.0, 0.0)      # New orientation\nvlm.setcoordsystem(frontwing, O, Oaxis)\n\n\nprintln(\"Generating vehicle...\")\n\n# Places the front wing into its own system that will be heaving\nheavingsystem = vlm.WingSystem()            # Tilting system\nvlm.addwing(heavingsystem, \"FrontWing\", frontwing)\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"BackWing\", backwing)\nvlm.addwing(system, \"Heaving\", heavingsystem)\n\ntilting_systems = (heavingsystem, );        # Tilting systems\n\nvlm_system = system;                        # System solved through VLM solver\nwake_system = system;                       # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            tilting_systems=tilting_systems,\n                            vlm_system=vlm_system,\n                            wake_system=wake_system\n                         );\n\n# NOTE: Through the `tilting_systems` keyword argument to `uns.VLMVehicle` we\n#       have declared that the front wing will be tilting throughout the\n#       simulation, acting as a control surface. We will later declare the\n#       control inputs to this tilting surface when we define the\n#       `uns.KinematicManeuver`\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n\n# Non-dimensional translational velocity of vehicle over time\nVvehicle(t) = [-1, 0, 0]        # <---- Vehicle is traveling in the -x direction\n\n# Angle of the vehicle over time\nanglevehicle(t) = zeros(3)\n\n# Control inputs\nangle_frontwing(t) = [0, amplitude*sin(2*pi*frequency * t*ttot), 0]  # Tilt angle of front wing\n\nangle = (angle_frontwing, )                 # Angle of each tilting system\nRPM = ()                                    # RPM of each rotor system (none)\n\nmaneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time.\n#       `angle` defines the tilting angle of each tilting system over time.\n#       `RPM` defines the RPM of each rotor system over time.\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n ","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"At this point we can verify that we have correctly defined the control inputs of the maneuver calling FLOWUnsteady.plot_maneuver as follows:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"uns.plot_maneuver(maneuver)","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-maneuver-controls.png\" alt=\"Pic here\" style=\"width: 85%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"Here we confirm that the angle of the tilting surface along the y-axis of the vehicle (pitch) will change sinusoidally with amplitude 5^circ, as expected. This function also plots the kinematics of the vehicle, which in this case are rather uneventful (straight line).","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"Now we continue defining the simulation:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = magVvehicle                          # Reference velocity to scale maneuver by\nRPMref = 0.0                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\n                                            # Maximum number of particles\nmax_particles = (nsteps+1)*(vlm.get_m(vehicle.vlm_system)*(p_per_step+1) + p_per_step)\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\nfigs, figaxs = [], []                       # Figures generated by monitors\n\n# Generate function that computes aerodynamic forces\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=true,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\nL_dir(t) = [0, 0, 1]                        # Direction of lift\nD_dir(t) = [1, 0, 0]                        # Direction of drag\n\n# Generate back wing monitor\nmonitor_backwing = uns.generate_monitor_wing(backwing, Vinf, b_back, ar_back,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name*\"-backwing\",\n                                            title_lbl=\"Back Wing\",\n                                            figname=\"back-wing monitor\",\n                                            )\n\n# Generate front wing monitor\nmonitor_frontwing = uns.generate_monitor_wing(frontwing, Vinf, b_front, ar_front,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=L_dir,\n                                            D_dir=D_dir,\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name*\"-frontwing\",\n                                            title_lbl=\"Front Wing\",\n                                            figname=\"front-wing monitor\",\n                                            )\n\nmonitors = uns.concatenate(monitor_backwing, monitor_frontwing)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    sigma_vlm_solver=sigma_vlm_solver,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_vlm_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    vlm_rlx=vlm_rlx,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitors,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_BackWing_vlm...vtk;\")\n    files *= run_name*\"_Heaving_FrontWing_vlm...vtk;\"\n    files *= run_name*\"_pfield...xmf;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~10 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"As the simulation runs, you will see the monitors (shown below) plotting the lift and drag coefficients over time along with the loading distribution.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-frontwing_convergence.png\"\n                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n    <br>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-backwing_convergence.png\"\n                                        alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"In these monitors, we clearly see the fluctuation of C_L and C_D over time due to the heaving motion (front wing) and the wake impingement (back wing). The plots of loading distribution seem very convoluted since the loading fluctuates over time, and all the time steps are super imposed in the monitor.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"To more clearly see what the loading distribution is doing, it is insightful to plot the loading as an animation as shown below.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//heavingwing-example-animation.gif\"\n                                        alt=\"Vid here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"info: Animations\nCheck the full example under examples/heavingwing/ to see how to postprocess the simulation and generate this animation.","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"info: Quasi-steady solver\nFLOWUnsteady also provides a quasi-steady solver for low-fidelity simulations that replaces the particle field with rigid semi-infinite wakes. The quasi-steady solver is invoked by simply changing the line that defines the vehicle fromvehicle = uns.VLMVehicle(...)tovehicle = uns.QVLMVehicle(...)(yes, it is only one character of a difference)Use the keyword argument save_horseshoes = false in uns.run_simulation to visualize the semi-infinite rigid wake. The quasi-steady simulation looks like this:","category":"page"},{"location":"examples/heavingwing/","page":"Heaving Wing","title":"Heaving Wing","text":"<p align=\"center\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/tandemheaving142_1.gif\" alt=\"Vid\" width=\"75%\"/>\n</p>","category":"page"},{"location":"examples/tetheredwing/#Tethered-Wing","page":"Tethered Wing","title":"Tethered Wing","text":"","category":"section"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<center>\n  <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//tetheredwing-example-00small.gif\" alt=\"Vid here\" style=\"width: 80%;\"/>\n</center>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"In this example we extend the simple wing case to fly a circular path. This simulates a kite tethered to the ground with a crosswind that causes it to fly in circles. The kite effectively acts as a turbine extracting energy from the wind to sustain flight, which is the basis for the field of airborne wind energy.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"This simulation exemplify the following features:","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"Translating and re-orienting the initial position of the vehicle using   FLOWVLM.setcoordsystem\nDefining a uns.KinematicManeuver object that prescribes the   kinematics of a circular path\nCustomizing the wing monitor (uns.generate_monitor_wing) to   compute and plot forces decomposed in arbitrary directions (in this   case, following the orientation of the vehicle along the circular path)\nMonitoring the vehicle state variables with   uns.generate_monitor_statevariables","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"#=##############################################################################\n# DESCRIPTION\n    Kite flying in a circular path with crosswind while tethered to the ground.\n    The kite is the same 45° swept-back wing from the previous example.\n\n# AUTHORSHIP\n  * Author          : Eduardo J. Alvarez (edoalvarez.com)\n  * Email           : Edo.AlvarezR@gmail.com\n  * Created         : Feb 2023\n  * Last updated    : Feb 2023\n  * License         : MIT\n=###############################################################################\n\nimport FLOWUnsteady as uns\nimport FLOWVLM as vlm\n\nrun_name        = \"tetheredwing-example\"    # Name of this simulation\n\nsave_path       = run_name                  # Where to save this simulation\nparaview        = true                      # Whether to visualize with Paraview\n\n\n# ----------------- GEOMETRY PARAMETERS ----------------------------------------\n# Wing description\nb               = 2.489                     # (m) span length\nar              = 5.0                       # Aspect ratio b/c_tip\ntr              = 1.0                       # Taper ratio c_tip/c_root\ntwist_root      = 0.0                       # (deg) twist at root\ntwist_tip       = 0.0                       # (deg) twist at tip\nlambda          = 45.0                      # (deg) sweep\ngamma           = 0.0                       # (deg) dihedral\n\n# Discretization\nn               = 50                        # Number of spanwise elements per side\nr               = 10.0                      # Geometric expansion of elements\ncentral         = false                     # Whether expansion is central\n\n# ----------------- SIMULATION PARAMETERS --------------------------------------\n# Freestream\nmagVinf         = 5.0                       # (m/s) freestream velocity\nmagVeff         = 49.7                      # (m/s) vehicle effective velocity\nAOAeff          = 4.2                       # (deg) vehicle effective AOA\nrho             = 0.93                      # (kg/m^3) air density\nqinf            = 0.5*rho*magVeff^2         # (Pa) static pressure\n\nVinf(X, t)      = magVinf*[1, 0, 0]         # Freestream function\n\n# Circular path\nR               = 3.0*b                     # (m) radius of circular path\nmagVvehicle     = sqrt(magVeff^2 - magVinf^2) # (m/s) vehicle velocity\nomega           = magVvehicle/R             # (rad/s) angular velocity\nalpha           = AOAeff - atand(magVinf, magVvehicle) # (deg) vehicle pitch angle\n\n# ----------------- SOLVER PARAMETERS ------------------------------------------\n# Time parameters\nnrevs           = 2.50                      # Revolutions to resolve\nnsteps_per_rev  = 144                       # Number of time steps per revolution\n\nttot            = nrevs / (omega/(2*pi))    # (s) total simulation time\nnsteps          = ceil(Int, nrevs * nsteps_per_rev) # Number of time steps\n\n# VLM and VPM parameters\np_per_step      = 4                         # Number of particle sheds per time step\n\nsigma_vlm_solver= -1                        # VLM-on-VLM smoothing radius (deactivated with <0)\nsigma_vlm_surf  = 0.05*b                    # VLM-on-VPM smoothing radius\nlambda_vpm      = 2.125                     # VPM core overlap\n                                            # VPM smoothing radius\nsigma_vpm_overwrite = lambda_vpm * magVeff * (ttot/nsteps)/p_per_step\n\nshed_starting   = true                      # Whether to shed starting vortex\nvlm_rlx         = 0.7                       # VLM relaxation\n\n# NOTE: In some cases the starting vortex can cause numerical instabilities at\n#       the beginning of the simulation. If so, consider omitting shedding of\n#       the starting vortex with `shed_starting=false`, or relax the VLM solver\n#       with `0.2 < vlm_rlx < 0.9`\n\n\n# ----------------- 1) VEHICLE DEFINITION --------------------------------------\nprintln(\"Generating geometry...\")\n\n# Generate wing\nwing = vlm.simpleWing(b, ar, tr, twist_root, lambda, gamma;\n                        twist_tip=twist_tip, n=n, r=r, central=central);\n\n# Rotate wing to pitch\nO = [0.0, 0.0, 0.0]                                 # New position\nOaxis = uns.gt.rotation_matrix2(0.0, -alpha, 0.0)   # New orientation\nvlm.setcoordsystem(wing, O, Oaxis)\n\n\nprintln(\"Generating vehicle...\")\n\n# Generate vehicle\nsystem = vlm.WingSystem()                   # System of all FLOWVLM objects\nvlm.addwing(system, \"Wing\", wing)\n\nvlm_system = system;                        # System solved through VLM solver\nwake_system = system;                       # System that will shed a VPM wake\n\nvehicle = uns.VLMVehicle(   system;\n                            vlm_system=vlm_system,\n                            wake_system=wake_system\n                         );\n\n # Rotate vehicle to be perpendicular to crosswind\n # and translate it to start at (x, y, z) = (0, R, 0)\n O = [0, R, 0]                                      # New position\n Oaxis = uns.gt.rotation_matrix2(0.0, -90, 0.0)     # New orientation\n\n vlm.setcoordsystem(system, O, Oaxis)\n\n\n# ------------- 2) MANEUVER DEFINITION -----------------------------------------\n\n# Translational velocity of vehicle over time\nfunction Vvehicle(t)\n\n    # NOTE: This function receives a non-dimensional time `t` (with t=0 being\n    #       the start of simulation and t=1 the end), and returns a\n    #       non-dimensional velocity vector. This vector will later be scaled\n    #       by `Vref`.\n\n    Vx = 0\n    Vy = -sin(2*pi*nrevs*t)\n    Vz = cos(2*pi*nrevs*t)\n\n    return [0, Vy, Vz]\nend\n\n# Angle of the vehicle over time\nfunction anglevehicle(t)\n\n    # NOTE: This function receives the non-dimensional time `t` and returns the\n    #       attitude of the vehicle (a vector with inclination angles with\n    #       respect to each axis of the global coordinate system)\n\n    return [0, 0, 360*nrevs*t]\nend\n\nangle = ()                                  # Angle of each tilting system (none)\nRPM = ()                                    # RPM of each rotor system (none)\n\nmaneuver = uns.KinematicManeuver(angle, RPM, Vvehicle, anglevehicle)\n\n# NOTE: `FLOWUnsteady.KinematicManeuver` defines a maneuver with prescribed\n#       kinematics. `Vvehicle` defines the velocity of the vehicle (a vector)\n#       over time. `anglevehicle` defines the attitude of the vehicle over time.\n#       `angle` defines the tilting angle of each tilting system over time (none\n#       in this case). `RPM` defines the RPM of each rotor system over time\n#       (none in this case).\n#       Each of these functions receives a nondimensional time `t`, which is the\n#       simulation time normalized by the total time `ttot`, from 0 to\n#       1, beginning to end of simulation. They all return a nondimensional\n#       output that is then scaled by either a reference velocity (`Vref`) or\n#       a reference RPM (`RPMref`). Defining the kinematics and controls of the\n#       maneuver in this way allows the user to have more control over how fast\n#       to perform the maneuver, since the total time, reference velocity and\n#       RPM are then defined in the simulation parameters shown below.\n\n\n\n\n# ------------- 3) SIMULATION DEFINITION ---------------------------------------\n\nVref = magVvehicle                          # Reference velocity to scale maneuver by\nRPMref = 0.0                                # Reference RPM to scale maneuver by\nVinit = Vref*Vvehicle(0)                    # Initial vehicle velocity\nWinit = pi/180*(anglevehicle(1e-6) - anglevehicle(0))/(1e-6*ttot)  # Initial angular velocity\n\n                                            # Maximum number of particles\nmax_particles = (nsteps+1)*(vlm.get_m(vehicle.vlm_system)*(p_per_step+1) + p_per_step)\n\nsimulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                    Vinit=Vinit, Winit=Winit);\n\n\n\n\n# ------------- 4) MONITORS DEFINITIONS ----------------------------------------\n\nfigs, figaxs = [], []                       # Figures generated by monitors\nimport FLOWUnsteady: @L_str                 # Macro for writing LaTeX labels\n\n# Generate function that computes aerodynamic forces\ncalc_aerodynamicforce_fun = uns.generate_calc_aerodynamicforce(;\n                                    add_parasiticdrag=true,\n                                    add_skinfriction=true,\n                                    airfoilpolar=\"xf-rae101-il-1000000.csv\"\n                                    )\n\n# Time-varying directions used to decompose the aerodynamic force\nN_dir(t) = [1, 0, 0]                        # Direction of normal force\nT_dir(t) = [0, sin(omega*t), -cos(omega*t)] # Direction of tangent force\nS_dir(t) = uns.cross(N_dir(t), T_dir(t))    # Spanwise direction\n\nX_offset(t) = system.O                      # Reference wing origin (for calculating spanwise position)\nS_proj(t)   = S_dir(t)                      # Reference span direction (for calculating spanwise position)\n\n# Generate wing monitor\nmonitor_wing = uns.generate_monitor_wing(wing, Vinf, b, ar,\n                                            rho, qinf, nsteps;\n                                            calc_aerodynamicforce_fun=calc_aerodynamicforce_fun,\n                                            L_dir=N_dir,\n                                            D_dir=T_dir,\n                                            X_offset=X_offset,\n                                            S_proj=S_proj,\n                                            CL_lbl=L\"Normal force $C_n$\",\n                                            CD_lbl=L\"Tangent force $C_t$\",\n                                            cl_lbl=L\"Sectional normal force $c_n$\",\n                                            cd_lbl=L\"Sectional tangent force $c_t$\",\n                                            cl_ttl=\"Normal force distribution\",\n                                            cd_ttl=\"Tangent force distribution\",\n                                            out_figs=figs,\n                                            out_figaxs=figaxs,\n                                            save_path=save_path,\n                                            run_name=run_name,\n                                            figname=\"wing monitor\",\n                                            );\n\n# Generate monitor of state variables\nmonitor_states = uns.generate_monitor_statevariables(; save_path=save_path,\n                                                       run_name=run_name,\n                                                       out_figs=figs,\n                                                       out_figaxs=figaxs,\n                                                       nsteps_savefig=10)\n\nmonitors = uns.concatenate(monitor_wing, monitor_states)\n\n\n# ------------- 5) RUN SIMULATION ----------------------------------------------\nprintln(\"Running simulation...\")\n\nuns.run_simulation(simulation, nsteps;\n                    # ----- SIMULATION OPTIONS -------------\n                    Vinf=Vinf,\n                    rho=rho,\n                    # ----- SOLVERS OPTIONS ----------------\n                    p_per_step=p_per_step,\n                    max_particles=max_particles,\n                    sigma_vlm_solver=sigma_vlm_solver,\n                    sigma_vlm_surf=sigma_vlm_surf,\n                    sigma_rotor_surf=sigma_vlm_surf,\n                    sigma_vpm_overwrite=sigma_vpm_overwrite,\n                    vlm_rlx=vlm_rlx,\n                    shed_starting=shed_starting,\n                    extra_runtime_function=monitors,\n                    # ----- OUTPUT OPTIONS ------------------\n                    save_path=save_path,\n                    run_name=run_name,\n                    );\n\n\n\n\n# ----------------- 6) VISUALIZATION -------------------------------------------\nif paraview\n    println(\"Calling Paraview...\")\n\n    # Files to open in Paraview\n    files = joinpath(save_path, run_name*\"_Wing_vlm...vtk\")\n    files *= \";\"*run_name*\"_pfield...xmf;\"\n\n    # Call Paraview\n    run(`paraview --data=$(files)`)\n\nend\n\n","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~20 minutes on a Dell Precision 7760 laptop.\n    <br>\n    Reduce resolution (n and steps) to speed up simulation without loss of accuracy.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"As the simulation runs, you will see the monitor shown below plotting the state variables of the vehicle. The components of both velocity and position follow a sinusoidal function, which is consistent with the circular path, while the angular velocity is constant.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//tetheredwing-example-statemonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>\n<br>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"The force monitor (shown below) plots the force components that are normal and tangential to the plane of rotation. Notice that the tangential force is negative, which is equivalent to having a negative drag, meaning that the vehicle is actually being propelled by the crosswind. Also notice that the forces are perturbed every time it completes a revolution. This is due to encountering the starting point of the wake that is slowly traveling downstream. It takes a couple revolutions for the forces to converge once the wake has been fully deployed.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"(<span style=\"color:red;\">red</span> = beginning,\n<span style=\"color:blue;\">blue</span> = end)","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//tetheredwing-example-wingmonitor.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"info: Disable monitors to speed up simulation\nFor unknown reasons, the simulation oftentimes halts in between time steps while plotting the monitors. This slows down the overall simulation time, sometimes taking up to 2x longer. If you are not particularly interested in the plots of the monitors, you can disable the plots passing the keyword disp_plot=false to each monitor generator.","category":"page"},{"location":"examples/tetheredwing/","page":"Tethered Wing","title":"Tethered Wing","text":"info: ParaView visualization\nThe .pvsm file visualizing the simulation as shown at the top of this page is available here: LINK (right click → save as...).To open in ParaView: File → Load State → (select .pvsm file) then select \"Search files under specified directory\" and point it to the folder where the simulation was saved.","category":"page"},{"location":"examples/vahana/#eVTOL-Aircraft","page":"eVTOL Aircraft","title":"eVTOL Aircraft","text":"","category":"section"},{"location":"api/flowunsteady-maneuver/#(2)-Maneuver-Definition","page":"(2) Maneuver Definition","title":"(2) Maneuver Definition","text":"","category":"section"},{"location":"api/flowunsteady-maneuver/","page":"(2) Maneuver Definition","title":"(2) Maneuver Definition","text":"FLOWUnsteady.KinematicManeuver\nFLOWUnsteady.DynamicManeuver\n\nFLOWUnsteady.plot_maneuver\nFLOWUnsteady.visualize_kinematics","category":"page"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.KinematicManeuver","page":"(2) Maneuver Definition","title":"FLOWUnsteady.KinematicManeuver","text":"KinematicManeuver{N, M}(angle, RPM, Vvehicle, anglevehicle)\n\nA vehicle maneuver that prescribes the kinematics of the vehicle through the functions Vvehicle and anglevehicle. Control inputs to each tilting and rotor systems are given by the collection of functions angle and RPM, respectively.\n\nARGUMENTS\n\nangle::NTuple{N, Function} where angle[i](t) returns the angles       [Ax, Ay, Az] (in degrees) of the i-th tilting system at time t (t is       nondimensionalized by the total time of the maneuver, from 0 to 1,       beginning to end).\nRPM::NTuple{M, Function} where RPM[i](t) returns the normalized RPM of       the i-th rotor system at time t. These RPM values are normalized by       an arbitrary RPM value (usually RPM in hover or cruise).\nVvehicle::Function where Vvehicle(t) returns the normalized vehicle       velocity [Vx, Vy, Vz] at the normalized time t. The velocity is       normalized by a reference velocity (typically, cruise velocity).\nanglevehicle::Function where anglevehicle(t) returns the angles       [Ax, Ay, Az] (in degrees) of the vehicle relative to the global       coordinate system at the normalized time t.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.DynamicManeuver","page":"(2) Maneuver Definition","title":"FLOWUnsteady.DynamicManeuver","text":"DynamicManeuver{N, M}(angle, RPM)\n\nA vehicle maneuver that automatically couples the kinematics of the vehicle with the forces and moments, resulting in a fully dynamic simulation. Control inputs to each tilting and rotor systems are given by the collection of functions angle and RPM, respectively.\n\nNOTE: This methods has not been implemented yet, but it may be developed in future versions of FLOWunsteady.\n\n\n\n\n\n","category":"type"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.plot_maneuver","page":"(2) Maneuver Definition","title":"FLOWUnsteady.plot_maneuver","text":"plot_maneuver(maneuver::KinematicManeuver; ti::Real=0, tf::Real=1,\n                            vis_nsteps=300, figname=\"maneuver\", tstages=[])\n\nPlots the kinematics and controls of a KinematicManeuver.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-maneuver/#FLOWUnsteady.visualize_kinematics","page":"(2) Maneuver Definition","title":"FLOWUnsteady.visualize_kinematics","text":"visualize_kinematics(sim::Simulation, nsteps::Int, save_path::String)\n\nSteps the vehicle through the prescribed kinematics, outputting VTK files of the vehicle at every time step. Use this to visualize and debug a maneuver.\n\nnsteps is the number of time steps in which to perform the maneuver. save_path is the path where to save the VTK files.\n\n\n\n\n\n","category":"function"},{"location":"installation/windows/#windows","page":"Windows Instructions","title":"Windows Instructions","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"(Tested on Windows 11)","category":"page"},{"location":"installation/windows/#Install-Windows-Subsystem-for-Linux-(WSL)","page":"Windows Instructions","title":"Install Windows Subsystem for Linux (WSL)","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Follow this guide to setup Ubuntu 22.04: LINK\nIf you run into issues, try the following:\nEnable bash for Windows LINK\nEnable virtualization LINK. For instance, here are instructions specific for a Dell Precision 7760: LINK1 LINK2 (make sure to check \"Hyper-V\")","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"To launch WSL, we recommend launching it from the Microsoft Store as opposed to the Programs Menu or the terminal, otherwise Windows' PATH will not be passed onto WSL.","category":"page"},{"location":"installation/windows/#Set-up-Environment","page":"Windows Instructions","title":"Set up Environment","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Once inside WSL, do the following","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Install system-level packages:\nsudo apt-get update\nsudo apt-get install cmake g++ mpich\nInstall python packages:\nsudo apt-get install python3-pip python3-tk\npip3 install matplotlib mpmath scipy --user\nCreate a folder where to install programs\nmkdir ~/Programs\ncd ~/Programs","category":"page"},{"location":"installation/windows/#Install-Julia","page":"Windows Instructions","title":"Install Julia","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Download Julia:\nwget -O julia.tar.gz \"https://julialang-s3.julialang.org/bin/linux/x64/1.8/julia-1.8.5-linux-x86_64.tar.gz\"\nDecompress Julia:\ntar -xvf julia.tar.gz -C ~/Programs/\nAdd Julia to user-level path:\nsudo ln -s ~/Programs/julia-1.8.5/bin/julia /usr/local/bin/","category":"page"},{"location":"installation/windows/#Install-ParaView","page":"Windows Instructions","title":"Install ParaView","text":"","category":"section"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Donwload and install ParaView v5.9.1\nIdentify the location of paraview.exe (most likely, this is C:\\Program Files\\ParaView 5.9.1\\bin\\)\nAdd the path of ParaView (e.g., C:\\Program Files\\ParaView 5.9.1\\bin\\) to the system-level PATH: LINK\nCreate a paraview alias inside WSL typing this in the WSL terminal:\nwhich paraview.exe | xargs -I{} sudo ln -s {} /usr/local/bin/paraview","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"info: ParaView 5.10+ on Windows\nParaView versions 5.10 and newer on Windows cannot open XDMF files (like the particle field) from the WSL file system. Please copy them to a Windows file system or use Paraview 5.9.1.","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"","category":"page"},{"location":"installation/windows/","page":"Windows Instructions","title":"Windows Instructions","text":"Now you can proceed with the general instructions (you can skip the Julia and ParaView since we already took care of that)","category":"page"},{"location":"examples/blownwing/#Blown-Wing","page":"Blown Wing","title":"Blown Wing","text":"","category":"section"},{"location":"examples/propeller-quasisteady/#Quasi-Steady-Solver","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"","category":"section"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"While unsteady simulations are resolved using the reformulated VPM, FLOWUnsteady also provides a quasi-steady solver for low-fidelity simulations. The quasi-steady solver replaces the particle field with semi-infinite rigid wakes in wings and blade-element momentum theory in rotors.","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"The quasi-steady solver is invoked by simply changing the line","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"VehicleType     = uns.UVLMVehicle","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"to","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"VehicleType   = uns.QVLMVehicle","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"in the previous sections. The results of the quasi-steady solver are shown below, predicted through blade-element momentum theory.","category":"page"},{"location":"examples/propeller-quasisteady/","page":"Quasi-Steady Solver","title":"Quasi-Steady Solver","text":"<center>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-Jsweep-exampleBEMT.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"},{"location":"theory/publications/#Publications","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"theory/publications/","page":"Publications","title":"Publications","text":"Alvarez, E. J., & Ning, A. (2021, in progress). <i>Unsteady Mixed-fidelity Aerodynamics Solver","category":"page"},{"location":"theory/publications/","page":"Publications","title":"Publications","text":"for Maneuvering Multirotor Aircraft</i>. AIAA SciTech Forum. <a href=\"https://github.com/byuflowlab/FLOWUnsteady/blob/master/docs/resources/AlvarezNing2021-SciTechAbstract-FLOWUnsteadysolver.pdf\"><b>[PDF]</b></a><br><br>","category":"page"},{"location":"theory/publications/","page":"Publications","title":"Publications","text":"Alvarez, E. J., Schenk, A., Critchfield, T., and Ning, A. (2020, in review). <i>Rotor-on-Rotor Aeroacoustic Interactions of Multirotor in Hover</i>. Journal of the American Helicopter Society. <a href=\"http://edoalvar2.groups.et.byu.net/public/AlvarezSchenkCritchfield2020-PresentationVFSForum-multirotornoiseinteractionsin_hoverSTATIC.pdf\"><b>[SLIDES]</b></a><a href=\"https://scholarsarchive.byu.edu/facpub/4053/\"><b>[PDF]</b></a><br><br>\nAlvarez, E. J., (2020). <i>Quasi-steady Aerodynamics Solver for a High-fidelity Controls Framework</i>. FLOWUnsteady Documentation. <a href=\"https://github.com/byuflowlab/FLOWUnsteady/blob/master/docs/resources/quasisteadysolver.pdf\"><b>[PDF]</b></a><br><br>\nAlvarez, E. J., & Ning, A. (2020). <i>High-fidelity Modeling of Multirotor Aerodynamic Interactions for Aircraft Design</i>. AIAA Journal. DOI: <a href=\"https://arc.aiaa.org/doi/10.2514/1.J059178\">10.2514/1.J059178</a> <a href=\"https://scholarsarchive.byu.edu/facpub/4179/\"><b>[PDF]</b></a><br><br>\nAlvarez, E. J., & Ning, A. (2019). <i>Modeling Multirotor Aerodynamic Interactions Through the Vortex Particle Method</i>. AIAA AVIATION Forum. DOI: <a href=\"https://doi.org/10.2514/6.2019-2827 \">10.2514/6.2019-2827</a> <a href=\"http://edoalvar2.groups.et.byu.net/public/AlvarezNing2019-AVIATION-Multirotoraerodynamicinteractionsthrough_VPM-STATIC.pdf\"><b>[SLIDES]</b></a><a href=\"https://scholarsarchive.byu.edu/facpub/3191/\"><b>[PDF]</b></a><br><br>\nAlvarez, E. J., & Ning, A. (2018). <i>Development of a Vortex Particle Code for the Modeling of Wake Interaction in Distributed Propulsion</i>. AIAA AVIATION Forum. DOI: <a href=\"https://doi.org/10.2514/6.2018-3646 \">10.2514/6.2018-3646</a> <a href=\"http://www.et.byu.edu/~edoalvar/public/AlvarezNing2018-AIAA-VPMdistibuted_propulsion-SLIDE-static.pdf\"><b>[SLIDES]</b></a><a href=\"https://scholarsarchive.byu.edu/facpub/2116/\"><b>[PDF]</b></a><br><br>","category":"page"},{"location":"api/flowunsteady-postprocessing-misc/#miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"api/flowunsteady-postprocessing-misc/","page":"Miscellaneous","title":"Miscellaneous","text":"  FLOWUnsteady.postprocess_statistics\n  FLOWUnsteady.postprocess_bladeloading","category":"page"},{"location":"api/flowunsteady-postprocessing-misc/#FLOWUnsteady.postprocess_statistics","page":"Miscellaneous","title":"FLOWUnsteady.postprocess_statistics","text":"postprocess_statistics(read_path, save_path, nums;\n                        # PROCESSING OPTIONS\n                        idens           = [\"\"],     # Use this to agglomerate multiple simulations\n                        to_exclude      = [],       # Exclude file names containing these words\n                        cyl_axial_dir   = nothing,  # Calculate cylindrical statistics if given an axial axis (vector)\n                        # OUTPUT OPTIONS\n                        prompt=true, debug=false,\n                        verbose=true, v_lvl=0)\n\nCalculate statistics of the simulation VTK outputs over a given range of time steps given by nums. Use this to calculate, for instance, the mean load distribution and fluctuations on wings and rotors.\n\n\n\n\n\n","category":"function"},{"location":"api/flowunsteady-postprocessing-misc/#FLOWUnsteady.postprocess_bladeloading","page":"Miscellaneous","title":"FLOWUnsteady.postprocess_bladeloading","text":"postprocess_bladeloading(read_path;\n                            O           = zeros(3),     # Rotor center\n                            rotor_axis  = [-1, 0, 0],   # Rotor centerline axis\n                            Ftot_axis   = nothing,      # Use a different centerline axis for forces if given\n                            filename    = \"singlerotor_Rotor_Blade1_vlm-statistics.vtk\", # File name\n                            fieldsuff   = \"-mean\"       # Suffix of fields \"Gamma\" and \"Ftot\", if any\n                            )\n\nRead a blade VTK file filename under directory read_path and returns the circulation and force components of the load distribution along the blade.\n\nReturn: rs, Gamma, Np, Tp, Rp, Zhat, Rhat, That, Ftot\n\n\n\n\n\n","category":"function"},{"location":"","page":"Intro","title":"Intro","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/flowunsteady-logo-wide03.png\" alt=\"FLOWUnsteady logo\" style=\"width:100%\">","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <span style=\"color:#2f6990;\">\n    <i>Interactional aerodynamics solver for multirotor aircraft and wind energy</i>\n  </span>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"right\">\n  <a href=\"https://github.com/byuflowlab/FLOWUnsteady\">\n    <img src=\"https://img.shields.io/badge/code-open%20source-brightgreen.svg\">\n  </a>\n  <a href=\"https://flow.byu.edu/FLOWUnsteady/\">\n    <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\">\n  </a>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"FLOWUnsteady is an open-source variable-fidelity framework for unsteady aerodynamics and aeroacoustics based on the reformulated vortex particle method (rVPM). This suite brings together various tools developed by the FLOW Lab at Brigham Young University: Vortex lattice method, strip theory, blade elements, 3D panel method, and rVPM. The suite also integrates an FW-H solver and a BPM code for tonal and broadband prediction of aeroacoustic noise. In the low end of fidelity, simulations are similar to a free-wake method, while in the high end simulations become meshless large eddy simulations.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Documentation: flow.byu.edu/FLOWUnsteady\nCode: github.com/byuflowlab/FLOWUnsteady","category":"page"},{"location":"#What-is-the-Reformulated-VPM?","page":"Intro","title":"What is the Reformulated VPM?","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"The reformulated VPM is a meshless CFD method solving the LES-filtered incompressible Navier-Stokes equations in their vorticity form,","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/vorticityns.png\" alt=\"img\" style=\"width:40%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"It uses a Lagrangian (meshless) scheme, which not only avoids the hurdles of mesh generation, but it also conserves vortical structures over long distances with minimal numerical dissipation.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"The rVPM uses particles to discretize the Navier-Stokes equations, with the particles representing radial basis functions that construct a continuous vorticity/velocity field. The basis functions become the LES filter, providing a variable filter width and spatial adaption as the particles are convected and stretched by the velocity field. The local evolution of the filter width provides an extra degree of freedom to reinforce conservations laws, which makes the reformulated VPM numerically stable (overcoming the numerical issues that plague the classic VPM).","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"This meshless LES has several advantages over conventional mesh-based CFD. In the absence of a mesh,   ","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"the rVPM does not suffer from the numerical dissipation introduced by a mesh\nintegrates over coarser discretizations without losing physical accuracy\nderivatives are calculated analytically rather than approximated through a stencil.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Furthermore, rVPM is highly efficient since it uses computational elements only where there is vorticity (rather than meshing the entire space), making it 100x faster than conventional mesh-based LES with comparable accuracy.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"While rVPM is well suited for resolving unbounded flows (wakes), complications arise when attempting to impose boundary conditions (solid boundaries) on the flow. This is because (1) the method is meshless, and (2) boundary conditions must be imposed on the Navier-Stokes equations in the form of vorticity. FLOWUnsteady is a framework designed to introduce solid boundaries into the rVPM using actuator models. Wings and rotors are introduced in the computational domain through actuator line and surface models that use low-fidelity aerodynamic methods (e.g., VLM, lifting line, panels, etc) to compute forces and embed the associated vorticity back into the LES domain.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/-6aR37Z6hig?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"#Variable-Fidelity-for-Preliminary-to-Detailed-Design","page":"Intro","title":"Variable Fidelity for Preliminary-to-Detailed Design","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"rVPM considerably reduces engineering time by avoiding the hurdles of mesh generation. Furthermore, since it is not limited by the time-step and stability constraints of conventional mesh-based CFD, rVPM can be used across all levels of fidelity, all in the same framework by simply coarsening or refining the simulation. In the low end of fidelity, simulations are similar to a free-wake method, while in the high end simulations become meshless large eddy simulations. Thus, FLOWUnsteady can be used as a high-fidelity tool that is orders of magnitude faster than mesh-based CFD, or as a variable-fidelity tool for the different stages of design.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"left\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/flowunsteady-variablefidelity.jpg\" alt=\"img\" style=\"width:100%\">\n</p>","category":"page"},{"location":"#Capabilities","page":"Intro","title":"Capabilities","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Simulation: Tilting wings and rotors • Rotors with variable RPM and variable pitch • Asymmetric and stacked rotors • Maneuvering vehicle with prescribed kinematicsrVPM Solver: Fast-multipole acceleration through ExaFMM • CPU parallelization through OpenMP • Second-order spatial accuracy and third-order RK time integration • Numerically stable by reshaping particles subject to vortex stretching • Subfilter-scale (SFS) model of turbulence associated to vortex stretching • SFS model coefficient computed dynamically or prescribed • Viscous diffusion through core spreadingWing Models: Actuator line model through lifting line + VLM • Actuator surface model through vortex sheet + VLM • Parasitic drag through airfoil lookup tablesRotor Model: Actuator line model through blade elements • Airfoil lookup tables automatically generated through XFOIL • Aeroacoustic noise through FW-H (PSU-WOPWOP) and BPMUnder development (🤞coming soon): Advanced actuator surface models through 3D panel method (for ducts, wings, and fuselage) • Bluff bodies through vortex sheet methodLimitations: Viscous drag and separation is only captured through airfoil lookup tables, without attempting to shed separation wakes • Incompressible flow only (though wave drag can be captured through airfoil lookup tables) • CPU parallelization through OpenMP without support for distributed memory (no MPI, i.e., only single-node runs)Coded in the Julia language for Linux, MacOS, and Windows WSL.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"More about the models inside FLOWUnsteady:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <a href=\"https://www.nas.nasa.gov/pubs/ams/2022/08-09-22.html\">\n    <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/nasaamsseminar2.png\" alt=\"https://www.nas.nasa.gov/pubs/ams/2022/08-09-22.html\" style=\"width:70%\">\n  </a>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Selected-Publications","page":"Intro","title":"Selected Publications","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"See the following publications for an in-depth dive into the theory and validation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"E. J. Alvarez, J. Mehr, & A. Ning (2022), \"FLOWUnsteady: An Interactional Aerodynamics Solver for Multirotor Aircraft and Wind Energy,\" AIAA AVIATION Forum. [VIDEO] [PDF]\nE. J. Alvarez & A. Ning (2022), \"Reviving the Vortex Particle Method: A Stable Formulation for Meshless Large Eddy Simulation,\" (in review). [PDF]\nE. J. Alvarez (2022), \"Reformulated Vortex Particle Method and Meshless Large Eddy Simulation of Multirotor Aircraft.,\" Doctoral Dissertation, Brigham Young University. [VIDEO] [PDF]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"#Examples","page":"Intro","title":"Examples","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Propeller: [Tutorial] [Validation] [Video]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/lUIytQybCpQ?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Rotor in Hover: [Tutorial] [Validation] [Video]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/u9SgYbYhPpU?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Blown Wing: [Tutorial] [Validation]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/prowimhtp-wvol34-cropped00.jpg\" alt=\"img\" style=\"width:100%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p><br></p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Airborne-Wind-Energy Aircraft: [Validation] [Video]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"left\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/circular-fdom-top02.jpg\" alt=\"img\" style=\"width:75%\">\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"eVTOL Transition: [Tutorial] [Video 1] [Video 2]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Mid-fidelity","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/d__wNtRIBY8?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"High-fidelity","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/-6aR37Z6hig?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Aeroacoustic Noise: [Tutorial] [Validation]","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/cfdnoise_ningdji_multi_005D_03_20.gif\" alt=\"Vid\" style=\"width:60%\"/>\n</p>","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<div style=\"position:relative;padding-top:50%;\">\n    <iframe style=\"position:absolute;left:0;top:0;height:80%;width:71.0%;\"\n        src=\"https://www.youtube.com/embed/ntQjP6KbZDk?hd=1\"\n        title=\"YouTube video player\" frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\"\n        allowfullscreen></iframe>\n</div>","category":"page"},{"location":"#Sponsors","page":"Intro","title":"Sponsors","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"<p align=\"center\">\n  <img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/sponsors01.png\" alt=\"img\" style=\"width:100%\">\n  <br><br><br>\n</p>","category":"page"},{"location":"#About","page":"Intro","title":"About","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"FLOWUnsteady is an open-source project jointly led by the FLOW Lab at Brigham Young University and Whisper Aero. All contributions are welcome.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"If you find FLOWUnsteady useful in your work, we kindly request that you cite the following paper [URL] [PDF]:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Alvarez, E. J., Mehr, J., and Ning, A., “FLOWUnsteady: An Interactional Aerodynamics Solver for Multirotor Aircraft and Wind Energy,” AIAA AVIATION 2022 Forum, Chicago, IL, 2022. DOI:10.2514/6.2022-3218.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"If you were to encounter any issues, please first read through the documentation and open/closed issues. If the issue still persists, please open a new issue.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Main developer    : Eduardo J. Alvarez (edoalvarez.com)\nCreated           : Oct 2019\nLicense           : MIT License","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"TODO","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"[ ] README\n[x] Rewrite description\n[ ] Add links to examples in README\n[ ] Theory\n[ ] Add a validations section compiling all validation studies\n[ ] List of publications\n[x] Brief theory\n[x] Installation instructions\n[ ] Visualization Guidelines\n[ ] Numerical recommendations notebook\n[ ] Examples\n[x] Simple wing\n[x] Circular path?\n[x] Heaving wing\n[x] Single rotor aero\n[ ] Single rotor noise\n[ ] Blown wing\n[ ] Vahana\n[ ] API\n[ ] Add pics of each monitor\n[x] Docstring for run_simulation\n[x] Polish docstrings\n[x] Vehicle: Rotor\n[x] Vehicle: SimpleWing and ComplexWing\n[x] Add database definition\n[x] Postprocessing: noise functions\n[x] Postprocessing: Fluid domain\n[x] Move large figure files to J Drive\n[x] Citing guide","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"[x] Compare results (CT, loading, and viz) with different fidelities vs BEMT vs RANS\n[ ] Rotor noise\n[x] Visualization guide\n[ ] Changing ParaView ugly default color\n[x] Cd monitor: Typically you can run one simulation with the dynamic       coeff, write down the mean Cd, then switch to the static model coeff       fixed to that value. It'll make the simulation 1.5x faster.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"<img src=\"http://edoalvar2.groups.et.byu.net/public/FLOWUnsteady/light/vorticitytake01-smallreducedslower02-2.gif\" alt=\"Vid here\" style=\"width: 400px;\"/>","category":"page"},{"location":"api/flowvpm-time/#Time-Integration","page":"Time Integration","title":"Time Integration","text":"","category":"section"},{"location":"api/flowvpm-time/","page":"Time Integration","title":"Time Integration","text":"FLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.rungekutta3\nFLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.euler\nFLOWUnsteady.vpm.euler","category":"page"},{"location":"api/flowvpm-time/#FLOWVPM.euler","page":"Time Integration","title":"FLOWVPM.euler","text":"Steps the field forward in time by dt in a first-order Euler integration scheme.\n\n\n\n\n\nSteps the field forward in time by dt in a first-order Euler integration scheme using the VPM reformulation. See notebook 20210104.\n\n\n\n\n\n","category":"function"},{"location":"api/flowvpm-time/#FLOWVPM.rungekutta3","page":"Time Integration","title":"FLOWVPM.rungekutta3","text":"Steps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme. See Notebook entry 20180105.\n\n\n\n\n\nSteps the field forward in time by dt in a third-order low-storage Runge-Kutta integration scheme using the VPM reformulation. See Notebook entry 20180105 (RK integration) and notebook 20210104 (reformulation).\n\n\n\n\n\n","category":"function"},{"location":"examples/propeller-jsweep/#J-Sweep","page":"J Sweep","title":"J Sweep","text":"","category":"section"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"Using the same rotor from the previous section, we now run a sweep of     the advance ratio J = fracu_inftyn d to characterize the     performance of the propeller.","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"#=##############################################################################\n# DESCRIPTION\n    Advance ratio sweep on APC 10 x7 propeller\n=###############################################################################\n\ncase_name       = \"propeller-Jsweep-example\"# Name of this sweep case\nsave_path       = case_name                 # Where to save this sweep\n\nJs              = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.775] # Advance ratios Vinf/(nD)\n\n# Create path where to save sweep\nuns.gt.create_path(save_path, true)\n\n# ----------------- J SWEEP ----------------------------------------------------\nfor J in Js\n\n    println(\"\\n\\n Running J = $(J)\")\n\n    magVinf         = J*RPM/60*(2*R)\n    Vinf(X, t)      = magVinf*[cosd(AOA), sind(AOA), 0] # (m/s) freestream velocity vector\n\n    # ------------- 1) VEHICLE DEFINITION ---------\n    println(\"\\tGenerating geometry...\")\n\n    # Generate rotor\n    rotor = uns.generate_rotor(rotor_file; pitch=pitch,\n                                            n=n, CW=CW, blade_r=r,\n                                            altReD=[RPM, J, mu/rho],\n                                            xfoil=xfoil,\n                                            ncrit=ncrit,\n                                            data_path=data_path,\n                                            verbose=false,\n                                            verbose_xfoil=false,\n                                            plot_disc=false\n                                            );\n\n\n    # Generate vehicle\n    system = vlm.WingSystem()                   # System of all FLOWVLM objects\n    vlm.addwing(system, \"Rotor\", rotor)\n\n    rotors = [rotor];                           # Defining this rotor as its own system\n    rotor_systems = (rotors, );                 # All systems of rotors\n\n    wake_system = vlm.WingSystem()              # System that will shed a VPM wake\n                                                # NOTE: Do NOT include rotor when using the quasi-steady solver\n    if VehicleType != uns.QVLMVehicle\n        vlm.addwing(wake_system, \"Rotor\", rotor)\n    end\n\n    vehicle = VehicleType(  system;\n                            rotor_systems=rotor_systems,\n                            wake_system=wake_system\n                            );\n\n    # ------------- 2) MANEUVER DEFINITION --------\n    # No changes\n\n    # ------------- 3) SIMULATION DEFINITION ------\n    simulation = uns.Simulation(vehicle, maneuver, Vref, RPMref, ttot;\n                                                     Vinit=Vinit, Winit=Winit);\n\n    # ------------- 4) MONITOR DEFINITION ---------\n    monitor_rotor = uns.generate_monitor_rotors(rotors, J, rho, RPM, nsteps;\n                                                t_scale=RPM/60,\n                                                t_lbl=\"Revolutions\",\n                                                save_path=save_path,\n                                                run_name=\"J$(ceil(Int, J*100))\",\n                                                disp_conv=false,\n                                                figname=\"rotor monitor J=$(J)\",\n                                                )\n\n    # ------------- 5) RUN SIMULATION -------------\n    println(\"\\tRunning simulation...\")\n\n    uns.run_simulation(simulation, nsteps;\n                        # ----- SIMULATION OPTIONS -------------\n                        Vinf=Vinf,\n                        rho=rho, mu=mu, sound_spd=speedofsound,\n                        # ----- SOLVERS OPTIONS ----------------\n                        p_per_step=p_per_step,\n                        max_particles=max_particles,\n                        vpm_viscous=vpm_viscous,\n                        sigma_vlm_surf=sigma_rotor_surf,\n                        sigma_rotor_surf=sigma_rotor_surf,\n                        sigma_vpm_overwrite=sigma_vpm_overwrite,\n                        vlm_rlx=vlm_rlx,\n                        shed_unsteady=shed_unsteady,\n                        shed_starting=shed_starting,\n                        extra_runtime_function=monitor_rotor,\n                        # ----- OUTPUT OPTIONS ------------------\n                        save_path=nothing,\n                        v_lvl=1, verbose_nsteps=24\n                        );\nend\n","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"<span style=\"font-size: 0.9em; color:gray;\"><i>\n    Run time: ~12 minutes on a Dell Precision 7760 laptop.\n</i></span>\n<br><br>","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"Check examples/propeller/propeller_jsweep.jl to postprocess and plot the results as shown below.","category":"page"},{"location":"examples/propeller-jsweep/","page":"J Sweep","title":"J Sweep","text":"<center>\n    <br>\n    <img src=\"https://edoalvar2.groups.et.byu.net/public/FLOWUnsteady//propeller-Jsweep-example.png\" alt=\"Pic here\" style=\"width: 100%;\"/>\n</center>","category":"page"}]
}
